#34장 이터러블
=================================================================

# 34-1. 이터레이션 프로토콜

- `이터레이션 프로토콜 (iteration protocol)`
  - ES6 에서 도입됨
  - 순회 가능한 (iterable) 데이터 컬렉션(자료구조) 을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙
  - 이터러블 프로토콜과 이터레이터 프로토콜이 있음


- ES6 이전
  - 순회 가능한 데이터 컬렉션, 즉 배열, 문자열, 유사 배열 객체, DOM 컬렉션 등은 통일된 규약 없이 각자 나름의 구조를 가지고 다양한 방법으로 순회함
- `ES6`
  - `순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일`
  - for ...of 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화

    
### 이터러블 프로토콜 (iterable protocol)
- Well-known Symbol 인 Symbol.iterator 를 프로퍼티 키로 사용한 메서드를 직접 구현하거나
- 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면
  - 이터레이터 프로토콜을 준수한 이터레이터를 반환
- 이러한 규약을 이터러블 프로토콜이라고 함
- `이터러블`
  - `이터러블 프로토콜을 준수한 객체`
  - `for ...of 문으로 순회 가능`
  - `스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용 가능`

### 이터레이터 프로토콜 (iterator protocol)
- 이터러블의 Symbol.iterator 메서드를 호출하면, 이터레이터 프로토콜을 준수한 `이터레이터` 반환
- `이터레이터`
  - `이터레이터 프로토콜을 준수한 객체`
  - 이터러블의 요소를 탐색하기 위한 포인터 역할
  - `next 메서드` 소유
  - next 메서드를 호출하면
    - 이터러블을 순회하며 value 와 done 프로퍼티를 갖는 `이터레이터 리절트 객체`를 반환
- 이러한 규약을 이터레이터 프로토토콜이라고 함


## 34-1-1. 이터러블

- 이터러블 프로토콜을 준수한 객체
- Symbol.iterator 를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 or 프로토타입 체인을 통해 상속받은 객체를 말함

```javascript
const isIterable = v => v !== null && typeof v[Symbol.iterator] === 'function';

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]);  // true
isIterable('');  // true
isIterable(new Map());  // true
isIterable(new Set());  // true
isIterable({});  // false
```

- 배열은 Array.prototype 의 Symbol.iterator 메서드를 상속받는 이터러블
- 이터러블은 for ...of 문으로 순회 가능 + 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용 가능

```javascript
const array = [1, 2, 3];

// 배열은 Array.prototype 의 Symbol.iterator 메서드를 상속받는 이터러블임
console.log(Symbol.iterator in array);  // true

// 이터러블인 배열은 for ...of 문으로 순회 가능
for (const item of array) {
    console.log(item);
}

// 이터러블인 배열은 스프레드 문법의 대상으로 사용 가능
console.log([...array]);  // [1, 2, 3]

// 이터러블인 배열은 배열 디스트럭처링 할당의 대상으로 사용 가능
const [a, ...rest] = array;
console.log(a, rest);  // 1, [2, 3]
```

- Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는, 이터러블 프로토콜을 준수한 이터러블 X
  - so, 일반 객체는 for ...of 문으로 순회 X + 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용 X

````javascript
const obj = { a: 1, b: 2 };

// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.
// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아님
console.log(Symbol.iterator in obj);  // false

// 이터러블이 아닌 일반 객체는 for ...of 문으로 순회할 수 없다
for (const item of obj) { // TypeError: obj is not iterable
    console.log(item);
}

// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용 X
const [a, b] = obj;  // TypeError: obj is not iterable
````

단, 2021년 1월 현재, TC39 프로세스의 stage4(Finished) 단계에 제안되어 있는 스프레드 프로퍼티 제안은, 일반 객체에 스프레드 문법의 사용을 허용함

```javascript
const obj = { a: 1, b: 2 };

// 스프레드 프로퍼티 제안(State 4) 은 객체 리터럴 내부에서 스프레드 문법의 사용을 허용함
console.log({...obj});  // { a: 1, b: 2 }
```

하지만 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 됨

## 34-1-2. 이터레이터

- 이터러블의 Symbol.iterator 메서드를 호출하면, 이터레이터 프로토콜을 준수한 이터레이터를 반환함
- #### 이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 `next 메서드`를 갖는다.

```javascript
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터를 반환함
const iterator = array[Symbol.iterator]();

// Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.
console.log('next' in iterator);  // true
```

- `이터레이터의 next 메서드`는 `이터러블의 각 요소를 순회하기 위한 포인터의 역할`을 함
- 즉, next 메서드를 호출하면 `이터러블을 순차적으로 한 단계씩 순회하며 순회 결과`를 나타내는 `이터레이터 리절트 객체(iterator result object)` 를 반환함

```javascript
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터를 반환함. 이터레이터는 next 메서드를 가짐
const iterator = array[Symbol.iterator]();

// next 메서드를 호출하면 이터러블을 순회하며, 순회 결과를 나타내는 이터레이터 리절트 객체를 반환함
// 이터레이터 리절트 객체 = value 와 done 프로퍼티를 갖는 객체
console.log(iterator.next());  // { value: 1, done: false }
console.log(iterator.next());  // { value: 2, done: false }
console.log(iterator.next());  // { value: 3, done: false }
console.log(iterator.next());  // { value: undefined, done: true }
```

# 34-2. 빌트인 이터러블

자바스크립트는 이터레이션 프로토콜을 준수한 객체인 빌트인 이터러블을 제공함

| 빌트인 이터러블   | Symbol.iterator 메서드                                                                  |
|:-----------|:-------------------------------------------------------------------------------------|
| Array      | Array.prototype[Symbol.iterator]                                                     |
| String     | String.prototype[Symbol.iterator]                                                    |
| Map        | Map.prototype[Symbol.iterator]                                                       |
| Set        | Set.prototype[Symbol.iterator]                                                       |
| TypedArray | TypedArray.prototype[Symbol.iterator]                                                |
| arguments  | arguments[Symbol.iterator]                                                           |
| DOM 컬렉션    | NodeList.prototype[Symbol.iterator]  <br/> HTMLCollection.prototype[Symbol.iterator] |


# 34-3. for ...of 문

for ...of 문은 이터러블을 순회하면서, 이터러블의 요소를 변수에 할당함

````markdown
for (변수선언문 of 이터러블) { ... }
````

for ...of 문은 for ...in 문의 형식과 매우 유사함

````markdown
for (변수선언문 in 객체) { ... }
````

- `for ...in 문`
  - 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입 프로퍼티 중에서, `프로퍼티 어트리뷰트 [[Enumerable]] 의 값이 true 인 프로퍼티를 순회하며 열거(enumeration)`
  - 이때 프로퍼티 키가 `심벌인 프로퍼티는 열거 X`



- `for ...of 문`
  - 내부적으로 `이터레이터의 next 메서드를 호출하여 이터러블을 순회`하며, next 메서드가 반환한 `이터레이터 리절트 객체의 value 프로퍼티 값`을 for ...of 문의 `변수에 할당`함
  - 이터레이터 리절트 객체의 done 프로퍼티 값이 `false` 이면 이터러블 `순회를 계속`하고, `true` 이면 이터러블 `순회를 중단`함

```javascript
for (const item of [1, 2, 3]) {
    // item 변수에 순차적으로 1, 2, 3 이 할당됨
  console.log(item);  // 1 2 3
}
```






































