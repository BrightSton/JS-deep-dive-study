# 5장 표현식과 문

> 개념을 이해한다는 것은 바로 용어를 정확히 이해하고 설명할 수 있다는 것이다.
> 
> **값에 대한 정확한 개념을 알자!**
<br>

## 5 - 1. 값

- **값(value)은** 표현식(expression)이 평가(evaluate)되어 생성된 결과를 말한다.

```jsx
// 10 + 20 은 평가되어 숫자 값 30을 생성한다.
10 + 20

// 10 + 20이 평가되어 30이란 값이 변수에 할당된다.
var score = 10 + 20
```
<br>

## 5 - 2. 리터럴

- **리터럴(literal)은** 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)을 말한다.

```jsx
// 숫자 리터럴 3
3
```
<br>

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/ebf4c919-c466-470e-9ab5-01fdf0da7f7d">
</div>
<br>

## 5 - 3. 표현식

- **표현식(expression)은** 값으로 평가될 수 있는 문(statement)으로 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

  - 리터럴도 값으로 평가되므로 리터럴 역시 표현식이다.

```jsx
var score = 50 + 50; // 50 + 50이 평가되어 100이라는 값을 생성하므로 50 + 50은 표현식

score; // 변수 score 식별자는 값을 참조하여 변수 값으로 평가되므로 표현식 

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수, 메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

- 표현식과 표현식이 평가된 값은 동등한 관계, 즉 **동치(equivalant)다.**

  - 표현식은 값처럼 사용할 수 있으며 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다.

  - 예를 들어, 좌항과 우항에 숫자 값이 위치해야 하는 `+` 연산자의 경우 숫자 값으로 평가될 수 있는 표현식 또한 좌항과 우항에 위치할 수 있다.

    ```jsx
    var x = 1 + 2; // x는 1 + 2 표현식과 3이라는 값과 동치이며, 3이라는 값으로 평가된다.
    
    // 식별자 표현식 x는 3으로 평가된다.
    x + 3; // x + 3 표현식은 6이라는 값으로 평가된다.
    ```
<br>

## 5 - 4. 문

- **문(statement)은** 프로그램을 구성하는 기본 단위이자 최소 실행 단위로 문의 집합이 곧 **프로그램**이며, 문을 작성하고 순서에 맞게 나열한 것이 **프로그래밍**이다.

- 문은 여러 **토큰**으로 구성되는데, **토큰(Token)이란** 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.



  - example) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;), 마침표(.) 등

  ```jsx
  var score = 1 + 2; // Token -> var, score, =, 1, +, 2, ; 
  ```
  
<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/2a7e0223-9a98-4c91-87ec-8f43d7347212">
</div>

- 문은 다른 말로 **명령문**이라고도 부르는데, 컴퓨터에 내리는 명령을 의미하고 문이 실행되면 명령이 실행되어 어떤 일이 발생하게 된다.

- 문은 **선언문, 할당문, 조건문, 반복문** 등으로 구분할 수 있다.

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo () {
  ...
}

// 조건문
if (x > 1) {
 console.log(x);
}

// 반복문
for (var i = 0; i < 2; i++) {
 console.log(i);
}
```
<br>

## 5 - 5. 세미콜론과 세미콜론 자동 삽입 기능

- **세미콜론(;)은** 문의 종료를 의미하는데, 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.

- 단, **if문, for문, 함수** 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는데, **코드 블록은** 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문이다.

- 자바스크립트에서는 문의 끝에 세미콜론을 붙이지 않아도 **세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이** 암묵적으로 수행된다.

- **그러나 ASI와 개발자의 예측이 일치하지 않는 경우도 있다.**

```jsx
function foo(){
	return
			{} 
	// 개발자의 예측 => return {};
	// ASI의 예측 => return; {};
}

var bar = function(){}
(function(){})();
// 개발자의 동작 결과 => var bar = function(){}; (function(){})();
// ASI의 동작 결과 => var bar = function(){} (function(){})();
// TypeError: (immediate value)(...) is not a function
```

- 세미콜론을 반드시 붙여야 한다는 주장이 대다수이지만, 붙이지 말아야 한다는 주장도 있다.

- **ESLint와** 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하는 등 대부분 세미콜론 사용을 권장하는 분위기이다.
<br>

## 5 - 6. 표현식인 문과 표현식이 아닌 문

- **표현식**은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있다.

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;

// 표현식이면서 완전한 문(할당문)이다.
x = 1 + 2;
```

- 표현식과 문을 구별하는 방법

  1. 값으로 평가될 수 있는 문 → **표현식인 문**

  2. 값으로 평가될 수 없는 문 → **표현식이 아닌 문**

  - 즉, 문을 변수에 할당해보면 **표현식인 문**은 값으로 평가되므로 에러가 발생하지 않지만, **표현식이 아닌 문**은 값으로 평가될 수 없으므로 에러가 발생한다.

```jsx
var foo = var x; // Error, var x는 표현식이 아닌 선언문이다.

var x;  // 선언문, 표현식 아님
x = 100; // 할당문, 표현식이면서 완전한 문
var foo = x = 100; // 표현식인 문은 값처럼 사용 가능
```

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/ee57cbae-39fb-4cf1-b362-7c7ed213bc20">
</div>
