# 38장 브라우저의 렌더링 과정

> 자바스크립트는 Node.js 등장으로 서버 사이트 애플리케이션 개발에도 사용가능한 범용 개발 언어가 되었다. <br>
> 하지만 여전히 웹 브라우저 환경에서 가장 많이 사용된다. <br>
> 대부분의 프로그래밍 언어는 OS나 VM 위에서 실행되는데 웹 애플리케이션의 클라이언트 사이드 JS는 브라우저에서 HTML, CSS와 함께 사용된다. <br>
> 즉, 브라우저 환경을 고려했을 때 보다 더 효율적인 클라이언트 사이드 JS 프로그래밍이 가능하다.

	[parsing]
	파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 실행하기 위해 문서의 문자열을 토큰으로 분해하고,
	토큰에 문법적 의미와 구조를 반영해 트리 구조의 자료구조인 파스 트리(parse tree/syntax tree)를 생성하는 일련의 과정이다.
	일반적으로 파싱이 완료된 이후 파스 트리를 기반으로 중간 언어인 바이트코드를 생성하고 실행한다.
	
	[rendering]
	렌더링은 HTML, CSS, JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것이다.
	
![image](https://github.com/user-attachments/assets/d5cb2447-f57d-4fb6-92e7-a6ebdf750e21)


> 1. 브러우저는 HTML, CSS, JS, image, font 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
> 2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과  CSS를 parsing하여 DOM과 CSSOM을 생성하고 이를 결합해 render tree를 생성한다.
> 3. 브라우저의 JS 엔진은 서버에서 응답된 JS를 parsing하여 AST를 생성하고 바이트코드로 변환하여 실행한다. <br>
이 때, JS는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있으며 이들은 다시 render tree로 결합된다.
> 4. render tree를 기반으로 html 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 painting 한다.

## 38.1 요청과 응답

> 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 서버로부터 응답받아 브라우저에 시각적으로 rendering 하는 것이다. <br>
> 서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다. <br>
> URL의 호스트 이름은 DNS를 통해 IP 주소로 변환되고 이 주소를 갖는 서버에게 요청을 전송한다.

> 루트 요청에는 명확한 리소스 요청 내용이 없지만 일반적으로 index.html을 응답하도록 설정되어 있다. <br>
> index.html이 아닌 다른 정적 파일을 요청하려면 정적 파일의 경로와 파일 이름을 URI의 호스트 뒤에 패스에 기술하여 서버에 요청한다.

> 브라우저 주소는 서버의 정적 파일 뿐만 아니라 동적으로 동적/데이터를 요청할 수도 있다.

> 요청과 응답은 개발자 도구의 Network 패널에서 확인 가능하다.

> index.html뿐만 아니라 다른 정적 파일(CSS, JS, image, font) 들도 응답된다. <br>
> 브라우저의 렌더링 엔진이 HTML을 파싱하는 도중에 외부 리소스 태그인 link 태그, img 태그, script 태그 등을 만나 HTML 파싱을 중단하고 해당 리소스 파일을 서버로 요청한다.

## 38.2 HTTP 1.1과 HTTP 2.0

- HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다.
- HTTP/1.1은 커넥션당 하나의 요청과 응답만 처리한다.
- HTTP/1.1은 HTML 문서 내에 포함된 여러 개의 리소스 요청은 개별적으로 전송되고 응답 또한 개별적으로 전송된다.
- HTTP/1.1은 리소스의 동시 전송이 불가능한 구조로 요청할 리소스의 개수에 비례해 응답 시간도 증가한다.

![image](https://github.com/user-attachments/assets/7a1308c1-2c57-44e7-910b-b40de6ae0bec)


- HTTP/2.0은 여러 리소스의 동시 전송이 가능하여 약 HTTP/1.1에 비해 페이지 로드 속도가 50% 정도 빠르다.

![image](https://github.com/user-attachments/assets/05945c32-f422-4dd8-b552-8c09b4f7412c)


## 38.3 HTML 파싱과 DOM 생성

> 브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수 텍스트이다. <br>
> 이 순수 텍스트 문서가 브라우저에 시각적인 픽셀로 렌더링되려면 HTML  문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하고 메모리에 저장해야 한다.

> 브라우저의 렌더링 엔진은 응답받은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조 DOM을 생성한다.

![image](https://github.com/user-attachments/assets/769b869a-c6d6-4d24-b790-ca3c3894dbe9)


> 1. 서버에 존재하는 HTML 파일이 브라우저의 요청으로 응답된다. 이때 서버는 HTML 파일을 읽어 메모리에 저장(2진수 바이트 형태)한 후 인터넷을 경유하여 응답한다. <br>
> 2. 브라우저는 서버가 응답한 HTML 문서를 바이트 형태로 응답 받고 meta 태그의 charset 어트리뷰트에 의한 인코딩 방식으로 문자열을 변환한다.  <br>
> 3. 문자열로 변환된 HTML 문서를 읽어 문법적 의미를 갖는 코드의 최소 단위(토큰)로 분해한다. <br>
> 4. 각 토큰들은 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성되며 DOM 구성의 기본 요소가 된다. <br>
> 5. HTML 문서는 HTML 요소의 집합으로 구성되고 HTML 요소는 중첩 관계를 갖는다. HTML 요소 간의 부자 관계를 반영하여 모든 노드를 트리 자료구조로 구성하고 이를 DOM 이라고 한다.

## 38.4 CSS 파싱과 CSSOM 생성

> 렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱해 DOM을 생성한다. 렌더링 엔진은 DOM을 생성하다가 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단한다. <br>
> 그리고 CSS 파일을 서버에 요청하여 로드한 CSS를 HTML과 동일한 파싱 과정을 거쳐 해석하여 CSSOM을 생성한다. <br>
> CSS 파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.

```style
body {
	font-size: 18px;
}

ul {
	list-style-type: none;
}
```

> CSSOM은 CSS의 상속을 반영하여 생성되며 다음과 같이 CSSOM이 생성된다.

![image](https://github.com/user-attachments/assets/1d528396-b38f-4659-96d1-f0c0bff391a0)


## 38.5 렌더 트리 생성

> DOM과 CSSOM은 렌더링을 위해 render tree로 결합된다. <br>
> render는 렌더링을 위한 트리 구조의 자료구조이며 렌더링되지 않는 노드와 CSS에 의해 비표시된 노드들은 포함되지 않는다.

![image](https://github.com/user-attachments/assets/25035144-eced-45e9-acc3-067b87147cd8)

> 이후 완성된 렌더 트리는 각 HTML 요소의 레이아웃을 계산하는 데 사용되고 브라우저 화면에 픽셀을 rendering하는 painting 처리에 입력된다.

![image](https://github.com/user-attachments/assets/350266fe-9531-4321-9bd1-f1fb437e502c)

> 지금까지 살펴본 브라우저의 렌더링 과정은 반복되서 실행될 수 있다.
>> JS에 의한 노드 추가 또는 삭제 <br>
>> 브라우저 창의 리사이징에 의한 뷰포트 크기 변경 <br>
>> HTML 요소의 레이아웃에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경

> 레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 들어 성능에 악영향을 준다. <br>
> 가급적 리렌더링이 발생하지 않도록 주의하자.

## 38.6 자바스크립트 파싱과 실행

> HTML 문서를 파싱한 결과물로 생성된 DOM은 HTML 문서의 구조와 정보, HTML 요소와 스타일 등을 변경할 수 있는 DOM API를 제공한다. <br>
> 즉, JS 코드로 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.

> CSS 파싱과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하며 DOM을 생성하다가 script 태그를 만나면 DOM 생성을 일시 중단한다. <br>
> 그리고 script 태그의 src 어트리뷰트에 정의된 JS 파일을 서버에 요청해 로드한 JS 파일이나 script 태그 내의 JS code 를 파싱하기 위해 JS 엔진에 제어권을 넘긴다. <br>
> 이후, JS 파싱과 실행이 종료되면 렌더링 엔진이 제어권을 받아 HTML 파싱이 중단된 지점부터 다시 파싱을 시작하여 DOM 생성을 재개한다.

> JS 파싱과 실행은 브라우저의 렌더링 엔진이 아닌 JS 엔진이 처리한다. <br>
> JS 엔진은 JS 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행한다. <br>
> 모든 JS 엔진은 ECMAScript 사양을 준수한다.

> 렌더링 엔진으로부터 제어권을 받은 JS 엔진은 JS 코드를 파싱하며 렌더링 엔진이 DOM, CSSOM을 생성하듯 JS 엔진은 JS를 해석하여 AST(추상적 구문 트리)를 생성한다. <br>
> 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

![image](https://github.com/user-attachments/assets/e5bdeca9-1b6c-4d33-a950-f80a7011d9b9)


### 토크나이징

- 단순 문자열인 JS 소스코드를 어휘 분석하여 문법적 의미를 갖는 코드의 최소 단위 (토큰)로 분해한다.
- 이 과정을 렉싱이라고 부르기도 하며 토크나이징과는 차이가 있다.

### 파싱

- 토큰들의 집합을 구문 분석하여 AST를 생성한다.
- AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조다.
- AST는 인터프리터나 컴파일러만이 사용하는 것이 아니다.
- aST를 사용하면 TS, Babel. Prettier 같은 트랜스파일러를 구현할 수 있다.

### 바이트코드 생성과 실행

- 파싱의 결과물로 생성된 AST는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행된다.
- V8 엔진의 경우 자주 사용되는 코드는 터보팬이라 불리는 컴파일러에 의해 최적화된 머신 코드로 컴파일되어 성능을 최적화한다.
- 코드의 사용 빈도가 적어지는 경우 다시 디옵티마이징하기도 한다.

## 38.7 리플로우와 리페인트

> JS 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다. <br>
> 이 때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저 화면에 다시 렌더링된다. <br>
> 이를 리플로우, 리페인트라고 한다.

![image](https://github.com/user-attachments/assets/08d0cce3-4913-4e4e-a8b1-54bd81ad3bda)

> 리플로우는 레이아웃 계산을 다시 하는 것으로 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생하면 실행된다. <br>
> 리페인트는 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것이다.

> 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아니며 레이아웃에 영향이 없는 변경은 리페인트만 실행된다. <br>

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

> 렌더링 엔진과 JS 엔진은 병렬적ㅇ로 파싱을 실행하지 않고 직렬적으로 파싱을 수행한다.

![image](https://github.com/user-attachments/assets/ea1fd0a5-6ff5-4f58-a4f0-26105d8013c3)

> 이처럼 브라우저는 동기적으로 위에서 아래 방향으로 순차적으로 HTML, CSS, JS를 파싱하고 실행한다. <br>
> 이것은 script 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다는 것으로 script 태그의 위치는 중요한 의미를 갖는다.

> 자바스크립트가 DOM이나 CSSOM을 변경하는 DOM API를 사용할 때 DOM이나 CSSOM이 이미 생성되어 있지 않은 상황은 문제가 될 수 있다.

> **body 요소의 가장 아래에 JS를 위치하는 것은 좋은 아이디어가 된다.**

> DOM 이 완성되지 않은 상태에서 JS가 DOM을 조작하면 에러가 발생할 수 있다.
> JS 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.

## 38.9 script 태그의 async/defer 어트리뷰트

- JS 파싱에 의한 DOM 생성이 중단되는 문제 해결을 위해 script 태그에 async/defer 어트리뷰트가 추가되었다.
- async/defer 어트리뷰트는 src 어트리뷰트를 통해 외부 js 파일이 로드되는 경우에만 사용 가능하다.

### async

> HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행된다. <br>
> 단 JS 파싱과 실행은JS 파일의 로드가 완료된 직후 직행되며 HTML 파싱은 중단된다. <br>
> 순서 보장이 필요한 script 태그에는 사용하지 말아야 한다.

![image](https://github.com/user-attachments/assets/c7879ecd-d607-4746-b798-cec28da32cf3)

### defer

> HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행된다. <br>
> JS의 파싱과 실행은 HTNML 파싱이 완료된 직후인 DOM 생성 완료 직후에 진행된다. <br>
> DOM 생성이 완료된 이후 실행되어야 할 JS에 유용하다.

![image](https://github.com/user-attachments/assets/8beabaf2-448c-4145-a8ba-189a16ea8e51)

