# 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 자바스크립트는 프로토타입 기반 객체지향 언어로 클래스가 필요없다.
- ES5에서 생성자 함수와 프로토타입으로 객체지향 언어의 상속 구현이 가능하다.
- ES6에서 클래스가 도입되는데 기존 프로토타입 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕으로 볼 수도 있다.
- 하지만, 클래스는 문법적 설탕이 아닌 새로운 객체 생성 메커니즘으로 보는 것이 더 합당하다.

1. 클래스는 new 연산자 없이 호출하면 에러가 발생한다.
2. 클래스는 상속을 지원하는 extend와 super 키워드를 제공한다. 
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 모든 코드는 암묵적으로 strict mode가 실행된다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false로 열거될 수 없다.

## 25.2 클래스 정의

```javascript
// 익명 클래스 표현식
const Person = {};

// 기명 클래스 표현식
const Person = class MyClass {};
```
1, 클래스는 함수로서 일급 객체이다.
2. 무명의 리터럴로 생성할 수 있다. (런타임에 생성 가능)
3. 변수나 자료구조에 저장 가능하다.
4. 함수의 매개 변수로 전달 가능하다.
5. 함수의 반환값으로 사용 가능하다.
6. 클래스의 몸체에는 0개 이상의 메서드가 정의 될 수 있다. (생성자 메서드, 프로토타입 메서드, 정적 메서드)

## 25.3 클래스 호이스팅

- 클래스 선언문으로 정의된 클래스는 함수 선언문과 같이 런타임 이전에 평가되어 함수 객체를 생성한다.
- 클래스가 평가될 때 생성된 함수 객체는 생성자 함수로서 constructor 함수를 호출할 수 있다.
- 생성자 함수로서 호출되는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 함께 생성된다.
- 프로토타입과 생성자 함수는 언제나 쌍으로 존재한다.
- 클래스는 클래스 정의 이전에 참조할 수 없다.

```javascript
// 클래스 선언문은 호이스팅이 발생하지 않는 것 처럼 보인다.
console.log(Person);
// 참조에러: Person은 초기화 이전에 접근할 수 없음

class Person {}
```

```javascript
const Person = '';

{
	// 호이스팅이 발생하지 않으면 ''이 출력되어야 한다.
	console.log(Person);
	/// 참조에러: Person은 초기화 이전에 접근할 수 없음
	
	클래스 선언문
	class Person {};
}
```

클래스는 let, const로 선언한 변수처럼 호이스팅 되며 선언문 이전에 TDZ에 빠져 호이스팅이 발생하지 않는 것처럼 동작한다.

## 25.4 인스턴스 생성

클래스는 생성자 함수로 new 연산자와 함께 호출되어 인스턴스를 생성한다.

```javascript
const Person class MyClass {};

// 함수 표현식과 같이 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person();

// MyClass는 함수와 같이 클래스 몸체 내부에만 유효한 식별자이다.
console.log(MyClass); // 참조에러: MyClass는 정의되지 않음

const you = new MyClass(); // 참조에러: MyClass는 정의되지 않음
```

## 25.5 메서드

### 25.5.1 constructor

- 인스턴스를 생성하고 초기화하는 메서드이다.
- 모든 함수 객체가 가지는 prototype 프로퍼티가 가리키는 프로토타입 객체 constructor프로퍼티는 클래스 자신을 가리킨다.
- new 연산자와 함께 클래스를 호출하면 클래스는 인스턴스를 생성한다.
- constructor는 메서드로 해석되지 않고 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.
- constructor 메서드는 2개 이상 존재할 수 없다.
- constructor 메서드는 생략 가능하다.
- constructor 메서드 내 객체를 반환하면 this 반환이 무시된다.
- constructor 메서드 내 원시타입 값을 반환하면 this가 반환된다.

```javascript
class Person {
	// 생성자
	constructor(name) {
		// 인스턴스 생성 및 초기화
		// name 프로퍼티가 인스턴스 프로퍼티로 추가된 것을 확인할 수 있다.
		this.name = name;
	}
}
```

	[클래스의 constructor 메서드와 프로토타입 constructor 프로퍼티]
	프로토타입의 constructor프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며 생성자 함수를 가리킨다.
	
## 25.5.2 프로토타입 메서드

- 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 프로토타입 메서드가 된다.

```javascript
class Person {
	constructor(name) {
		this.name = name;
	}
	
	// 프로토타입 메서드
	sayHi() {
		console.log(`Hi! ${this.name}`);
	}
}

const you = new Person('Lee');
you.sayHi(); // Hi! Lee
```

- 생성자 함수와 같이 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

```javascript
// you 객체의 프로토타입은 Person.prototype이다.
Object.getPrototypeOf(you) === Person.prototype; // true
you instanceof Person; // true

// Person.prototpye의 프로토타입은 Objcet.prototype이다.
Object.getPrototypeOf(Person.prototpye) === Object.prototype; // true
you instanceof Object; // true

// you 객체의 constructor는 Person 클래스이다.
you.constructor === Person; // true
```

### 25.5.3 정적 메서드

- 인스턴스를 생성하지 않아도 호출되는 메서드
- 정적 메서드는 클래스에 바인딩된 메서드가 된다.
- 인스턴스의 프로토타입 체인상에 정적 메서드가 바인딩된 클래스는 존재하지 않는다..

```javascript
class Person {
	constructor(name) {
		this.name = name;
	}
	
	// 정적 메서드
	static sayHi() {
		console.log('Hi');
	}
}

Person.sayHi(); // Hi
```

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출한다. (클래스 자체에 바인딩된 상태)
3. 프로토타입 메서드는 인스턴스로 호출한다. (생성자 메서드 내의 프로퍼티를 참조한다.)
4. 정적 메서드는 인스턴스 메서드를 참조할 수 없고 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

### 25.5.5 클래스에서 정의한 메서드 특징

1. function 키워드를 생략한 메서드 축약 표현 사용
2. 객체 리터럴과 달리 클래스에 메서드 정의 시 콤마가 필요 없다.
3. 암묵적으로 strict mode가 실행된다.
4. for ... in, OBject.keys 등 열거될 수 없다. [[Enumerable]] 값이 false 이므로
5. 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor이다. new 연산자와 함께 호출할 수 없다.

### 25.5.6 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
  - new 연산자와 함께 클래스르 호출하면 암묵적으로 빈객체가 생성된다.
  - 빈 객체는 클래스가 생성한 인스턴스로 인스턴스의 프로토타입으로 클래스의 prototpye 프로퍼티가 가리키는 객체가 설저오딘다.
  - 암묵적으로 생성된 빈객체인 인스턴스는 this에 바인딩된다.
  - constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.

2. 인스턴스 초기화
  - constructor 내부 코드가 실행되어 this에 바인딩된 인스턴스를 초기화한다.
  - this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor의 인수를 초기값으로 초기화한다.
  - constructor가 생략되었다면 이 과정은 생략된다.

3. 인스턴스 반환
  - 클래스의 모든 처기 후 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

```javascript
class Person {
	constructor(name) {
		console.log(this);
		console.log(Object.getPrototypeOf(this) === Person.prototype); // true
		
		// 2. this에 바인딩되어 있는 인스턴스를 초기화 한다.
		this.name = name;
		
		// 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
	}
}
```
