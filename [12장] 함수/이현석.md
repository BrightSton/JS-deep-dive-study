# 12장 함수

## 12.1 함수란?

- 수학의 함수는 입력을 받아 출력을 내보내는 일련의 과정을 정의.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/5aa3df5d-4d33-49df-8f74-39d744c1c01e">
</div>

- 프로그래밍에서도 같은 개념으로 일련의 과정을 **문(statement)으로** 구현하고 코드 블록으로 감싸서 **하나의 실행 단위로 정의.**

  - 함수 내부로 입력을 전달받는 **변수가 매개변수, 입력은 인수, 출력이 반환값.**
 
  - **함수 정의**를 통해 생성하고, 인수를 매개 변수를 통해 함수에 전달하는 행위인 **함수 호출**을 통해 실행.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/a869f81d-fd5e-40fa-a443-b47f39a22910">
</div>
<br>

## 12.2 함수를 사용하는 이유

- 실행 시점을 개발자가 결정할 수 있고 몇 번이든 재사용이 가능한데, **코드의 재사용**이라는 측면에서 매우 유용.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/97dabc24-c689-40d4-a8d7-87a97304279b">
</div>

- 코드의 중복 억제 및 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높임.

- **객체 타입의 값**으로 이름을 붙일 수 있고 함수 이름은 **함수 자신의 역할을 잘 설명**해야 함.

  - 함수의 내부 코드를 이해하지 않고도 함수의 역할 파악을 가능하게 해서 **코드의 가독성** 향상.
<br>

## 12.3 함수 리터럴

- **객체 타입의 값**이기에, 숫자 값을 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 **함수 리터럴로 생성.**

  - **함수 리터럴**은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성.
 
  ```jsx
  // 변수에 함수 리터럴을 할당
  var f = fucntion add(x, y) {
	  return x + y;
  }
  ```
 
  - 함수 리터럴의 구성 요소.

  <div align="center">
    <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/6f55b93d-64e6-4b59-ae7f-dae5fe0d90fe">
  </div>

- 리터럴은 값을 생성하기 위한 표기법으로 **함수 리터럴**도 값을 생성하며, 이 값이 객체로 **함수는 객체다.**

  - 함수는 객체이면서, 일반 객체와 차별성을 가지는데,

  - 일반 객체는 호출할 수 없지만 **함수는 호출 가능**.
 
  - 함수 객체만의 **고유한 프로퍼티를 가짐.**
 
  - 따라서 함수 객체는 **일급 객체에 해당.**
<br>

## 12.4 함수 정의

- 함수 호출 이전에 **인수를 전달받을 매개변수**와 **실행할 문들**, **반환할 값**을 지정하는 것.

- 자바스크립트 엔진에 의해 평가되어 함수 객체가 되고 함수로 정의.

- 함수 정의에는 4가지 방법이 존재

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/a17b61ec-d353-4584-97ec-c2ddc5fbfe5d">
</div>

- 모든 함수 정의 방식은 함수를 정의한다는 면에서는 동일하지만 미묘한 차이가 존재.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/a1a3a928-1841-4884-b50f-e78f621bfc82">
</div>
<br>

### 12.4.1 함수 선언문

-  함수 리터럴과 형태가 동일하나, **함수 이름 생략 불가능.**


- **함수 선언문은 표현식이 아닌 문**.

  - 함수 선언문을 콘솔에서 실행하면 완료 값 **undefined가 출력.**
 
  - 만약 표현식인 문이라면 표현식이 평가되어 생성된 함수가 출력.

  <div align="center">
    <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/fb9015c1-372f-49b9-b306-5108d064ee51">
  </div> 
    
- 표현식이 아닌 문은 변수에 할당할 수 없는데,  변수에 할당되는 것처럼 보이는 것이 가능.

  - 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일.
 
  - 또한, 함수 객체를 생성한다는 점에서 동일하지만 **호출에 차이.**

  - 자바스크립트 엔진이 코드의 문맥에 따라 해석의 차이 존재. 

    - **동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우.**
   
      - 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성.
      
      - 거기에 함수 객체를 할당하기 떄문에 별도의 함수 객체를 가르키는 식별자가 없어도 참조 가능.
     
      - 즉, 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출.
     
    <div align="center">
      <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/c7854933-dfde-4524-abd2-f0adc06ba8f5">
    </div>

    - **표현식인 문인 함수 리터럴 표현식으로 해석하는 경우.**

      -  함수 외부에서 함수 이름으로 참조할 수 없으므로 함수 이름으로 함수를 호출할 수 없다는 의미.
     
      -  함수를 가리키는 식별자가 없다는 것과 마찬가지.

    ```jsx
    // 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
    // 함수 선언문에서는 함수 이름을 생략할 수 없다.
    function foo() {
      console.log("foo");
    }
    foo(); // foo

    // 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석
    // 함수 리터럴에서는 함수 이름을 생략할 수 있다.
    (function bar() { console.log("bar"); });
    bar(); // ReferenceError: bar is not defined;
    ```   
