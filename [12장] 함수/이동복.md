# 12장 함수

## 12.1 함수란?

함수는 **일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것**으로 매개변수, 인수, 반환 값을 가진다.

## 12.2 함수를 사용하는 이유

동일한 작업을 반복하여 수행하는 경우 정의된 함수를 **재사용**하여 효율적으로 작업할 수 있다.
함수를 통해 **유지보수의 편의성**과 **코드의 신뢰성**을 높일 수 있다. **코드의 가독성** 또한 향상시킬 수 있다.

## 12.3 함수 리터럴

```javascript
// 함수 리터럴
// 1. function 키워드
// 2. 함수이름
// 3. 매개 변수 목록
// 4. 함수 몸체
function add(x, y) {
	return x + y;
}

// 함수는 객체로서 변수에 할당 될 수 있다.
// 함수의 이름이 있으면 기명 함수, 없으면 익명 함수라 칭한다.
var sub = function (x, y) {
	return x - y;
}

// 함수는 호출될 수 있다.
sub(1, 2);
```

## 12.4 함수 정의

```javascript
// 1. 함수 선언문
// 함수 이름과 같은 식별자가 암묵적으로 생성된다.
function f1() {}

// 2. 함수 표현식
// 피연산자로서 평가되거나 변수에 할당되는 경우
// 일반적으로 익명함수
var f2 = function() {};

// 3. Function 생성자 함수
// 생성자로 객체를 만들어진 함수
// new 키워드는 생략 가능하다.
var f3 = new Function('a', 'b', 'return a-b;');

// 4. 화살표 함수(ES6)
// 간소화된 함수
var f4 = () => {}
```

### 12.4.1 함수 선언문

```javascript
// 함수명이 생략될 수 없다.
// 문법 에러
function (x, y) {
	return x + y;
}
```

**함수 선언문은 표현식이 아닌 문이다.**
아래의 코드에서 함수 add는 함수 리터럴로 해석되어 함수 표현식이다.

함수 선언문과 함수 리터럴이 헷갈릴 경우 이 2가지의 경우를 기억하자.
이 때에 해당한다면 항상 함수 표현식이다.

1. 함수가 변수에 할당된 경우
2. 함수가 피연산자에 의해 평가된 경우

```javascript
// 함수명 add는 함수 몸체 스코프까지만 존재한다.
// 변수에 할당된 함수는 함수 표현식이다. 따라서, 함수 선언식이 아니므로 add 변수는 암묵적으로 생성되지 않는다.
var add1 = function add(x, y) {
	return x + y;
};

// add1으로 함수 호출이 가능하다.
console.log(add1(1, 2));
console.log(add(1, 2)); // 에러
```

```javascript
// 함수 선언문이다.
// foo가 식별자로 암묵적으로 생성되어 호출될 수 있다.
function foo() { console.log('foo'); }
foo();

// 함수 표현식이다. 그룹 연산자 내에서 평가된 함수로 호출되어질 수 없다.
(function bar() { console.log('bar'); });
bar(); //  참조에러: bar는 정의되어지지 않았음
```

**함수는 함수 이름이 아닌 함수 객체를 가리키는 식별자로 호출된다.**

### 12.4.2 함수 표현식

자바스크립트의 함수는 값처럼 변수에 할당 될 수 있고, 프로퍼티 값이 될 수 있고, 배열의 요소도 될 수 있다.
이와 같이 값의 성질을 갖는 객체는 **일급 객체**라고 한다.

함수 표현식에서 함수 리터럴은 일반적으로 함수명을 생략한다.

```javascript
// 함수 표현식
// 평가되어 값으로 식별자에 할당되었다.
var add = function foo (x, y) {
	return x + y;
}

// 함수 객체가 할당된 add 식별자로 호출 가능
console.log(add(2, 5)); // 7

// 평가되어진 함수이므로
// 함수 선언문과 같이 foo라는 함수명과 동일한 식별자가 생성되지 않음.
console.log(foo(2, 5)); // 참조에러: foo는 정의되지 않음
```

### 12.4.3 함수 생성 시점과 함수 호이스팅

```javascript

// 함수 참조
// 함수 선언문은 실행 컨텍스트 단계에서 정의됨
// 함수 표현식은 런타임 단계에서 할당되므로 변수 sub만 선언된 상태
console.log(add); // add(x, y)
console.log(sub); // undefined

// 함수 호출
// 위와 같은 맥락으로 함수 표현식은 할당되기 전이므로 에러 발생
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // 타입 에러: sub는 함수가 아니다

function add(x, y) {
 return x + y;
}

var sub = function (x, y) {
 return x - y;
}
```

**함수 호이스팅: 변수 선언과 같이 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것**

### 12.4.4 Function 생성자 함수

빌트인 함수 Function 생성자 함수에 매개변수, 함수 몸체를 문자열로 전달하여 new 연산자와 함께 호출한다.
이런 방식으로 함수 객체를 생성하여 반환 받고 new 연산자 없이도 호출 가능하다.

	생성자 함수
	객체를 생성하는 함수를 의미한다. 객체를 생성하는 방식은 객체 리터럴 이외에 다양한 방법이 있다.
	
```javascript
// Function 생성자 함수는 클러저를 생성하지 않는다.
// 함수 선언문이나 함수표현식으로 생성된 함수와 동일하게 동작하지 않는다.
var add  = (function() {
	var a = 10;
	return new Function('x', 'y', 'return x + y + a;');
}());

conosle.log(add(1. 2)); // 참조에러: a는 정의되지 않았음
```

### 12.4.5 화살표 함수

- 생성자 함수로 사용할 수 없다.
- 기존 함수와 this 바인딩이 다르다.
- prototype 프로퍼티가 없다.
- arguments 객체를 생성하지 않는다.
  
```javascript
// ES6에서 도입된 간략화된 함수
const add = (x, y) => x + y;
console.log(2, 5); // 7
```

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개 변수가 생성되고 undefined로 초기화된 후 인수가 순서대로 할당된다.
- 함수가 호출될 때마다 매개변수는 이와 같은 흐름을 거친다.
- 함수 내에 선언된 변수는 전역 변수로 사용될 수 없다.
- 함수 매개변수를 초과한 인수는 arguments 객체의 프로퍼티로 보관된다.

```javascript
// 매개변수 x, y를 가진다.
function add(x, y) {
 return x + y;
}

// 인수1, 2로 add 함수를 호출한다.
var result = add(1, 2);
```

### 12.5.2 인수 확인

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

5가지의 방법으로 매개변수의 인수의 값을 설정하거나 유효성 확인을 할 수 있다.
변수 타입 체크. 단축평가로 매개변수 기본값 할당. ES6 매개변수 기본값 할당. 타입스크립트 사용. arguments 인수 갯수 비교. 

### 12.5.3 매개변수의 최대 개수

매개 변수는 최소화하는 것이 좋고 최소 0개까지 전달할 수 있다.
**이상적인 함수는 한 가지 일만 해야 하고 가급적 작게 만들어야 한다.**
매개변수에 객체를 선언하여 인수로 전달하는 것도 가능하다.
함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체도 변경되어 부수 효과가 발생하므로 주의해야 한다.

### 12.5.4 반환문

return 키워드로 함수 결과 값을 외부로 반환할 수 있다.

- return 값이 없거나 return하지 않는 경우 undefined을 반환한다.
- return 키워드에는 세미콜론이 자동 삽입된다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

*참조에 의한 전달 대응 방법*
- 객체 변경을 추적하기 위해 옵저버 패턴 등을 사용할 수 있다.
- 객체를 불변 객체로 만들어 원시 값처럼 변경 불가능한 값으로 동작하게 만든다. (깊은 복사)

```javascript
// 원시 값은 값이 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
function changeVal(primitive, obj) {
 primitive += 100;
 obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee' };

console.log(num);
console.log(person);

changeVal(num, person);

console.log(num); // 100
console.log(person); // { name: 'Kim' }
```

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

```javascript
// 그룹연산자 내에서 평가되어 함수 리터럴로 해석된다.
// 그룹연산자를 벗어나서 호출될 수 없다.
(function foo() {
	var a = 3;
	var b = 5;
	retrun a * b;
}())

// 함수 선언문은 함수명을 생략할 수 없다.
function() {}(); // 문법 에러: 함수 선언문은 함수 이름을 필수로 한다.

// 함수 선언문으로 함수 몸체가 종결성을 갖는다.
fuction foo() {}(); // 문법 에러: 예기치 않은')' 토큰

// 그룹연산자 내 피연산자가 존재하지 않으면 에러
(); // 문법 에러: 예기치 않은')' 토큰

(function(){
}());

(function(){
})();

!function(){
}();

+function(){
}();

// 인수 전달 및 결과 값 반환이 가능하다.
var res = (function(a, b) {
	return a * b;
}(3, 5));

console.log(res); // 15
```

### 12.7.2 재귀 함수

- 자기 자신을 호출하는 함수 
- 재귀 함수 내에 호출을 탈출할 수 있는 탈출 조건이 반드시 있어야 한다.

```javascript
function factorial(n) {
 if(n <= 1) return 1;
 
 return n * factorial(n - 1);
}

factorial(3); // 3! = 3 * 2 * 1 = 6
```

### 12.7.3 중첩 함수

내부함수: 함수 내부에 정의된 함수를 중첩 함수라고도 한다.
외부함수: 중첩함수를 포함하는 함수
일반적으로 중첩함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할을 한다.

```javascript
function outer() {
 var x= 1;
 
 function inner() {
  var y = 2;
  console.log(x + y); // 3
 }
 
 inner();
}

outer();
```

### 12.7.4 콜백 함수

콜백함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
고차함수: 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수

**고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.**
**즉, 콜백함수는 고차 함수에 의해 호출되며 이 때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**
```javascript
function repeat(n, f) {
 for(var i = 0; i < n; i++) {
  f(i);
 }
}

var logAll = function (i) {
 console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4

vra logOdds = function (i) {
 if(i % 2) console.log(i);
}

repeat(5, logOdds); // 1 3
```

*고차함수의 매개변수로 함수 리터럴을 직접 작성하면 고차함수가 호출될 때마다 평가되어 함수 객체를 생성한다.*
*따라서 고차 함수가 자주 호출된다면 콜백 함수를 정의하여 인수로 전달하는 편이 효율적이다.*

```javascript
// 고차함수가 호출될 때마다 평가되어 익명 함수 리터럴 객체 생성
repeat(5, function (i) {
 if(i % 2) console.log(i);
})
```
콜백함수는 비동기 처리뿐 아니라 배열 고차 함수에도 사용된다.

```
var res = [1, 2, 3].map(function (item) {
 return item * 2;
}); // [2, 4, 6]

var res = [1, 2, 3].filter(function (item) {
 return item % 2;
}); // [1, 3]

var res = [1, 2, 3].reduce(function (acc, cur) {
 return acc + cur;
}, 0); // 6
```

### 12.7.5 순수 함수와 비순수 함수

순수함수: 부수 효과가 없는 함수
비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수

```javascript
// 최소 하나 이상의 인수를 받는다.
// 인수를 전달받지 않는 순수 함수는 상수와 마찬가지이다.
// 인수의 불변성을 유지한다.
// 함수의 외부 상태를 변경하지 않는다.
var count = 0;

function increase(n) {
	return ++n;
}

// 재할당을 했을 뿐  함수 내에서 count 자체의 값이 변경되지는 않았다.
count = increase(count); // 1
count = increase(count); // 2
```

```javascript
// 함수 외부 상태를 직접 참조하여 외부 상태에 의존하게 된다.
// 반환값이 변할 수 있고 외부 상태도 변경 가능하므로 비순수 함수이다.
var count = 0;

function increase() {
	return ++count;
}

increase(); // 1
increase(); // 2
```

함수형 프로그래밍은 순수 함수와 보조 함수의 조합으로 부수 효과를 최소화하여 불변성을 지향하는 프로그래밍 패러타임이다.
로직 내 존재하는 조건문, 반복문을 제거하여 복잡성을 해결하고 변수 사용을 억제하거나 생명주기를 최소화하는 등
상태 변경을 피해 오류를 최소화하는 것을 목표로한다.
