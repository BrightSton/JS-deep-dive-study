# 19장 프로토타입

- 자바스크립트는 `명령형`, `함수형`, `프로토타입 기반 객체 지향 프로그래밍`을 지원하는 **멀티 패러다임 프로그래밍 언어.**

- 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 언어.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/40e451fd-f94d-475c-8bf1-d1c0e90fb734">
</div>

- 자바스크립트를 이루고 있는 거의 모든 것이 객체로, 원시 타입을 제외한 모든 값들이 객체.(함수, 배열, 정규 표현식 등)
<br>

## 19.9 프로토타입 교체

- 프로토타입은 임의의 다른 객체로 변경 가능.

  - 부모 객체인 프로토타입을 동적 변경 가능하다는 것을 의미.
 
  - 이러한 특징 활용을 통해 객체 간 상속 관계를 동적 변경 가능.
 
  - 즉, 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체 가능.
 
### 19.9.1 생성자 함수에 의한 프로토타입의 교체

```jsx
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHe11o() {
      console.log(`Hi! My name is ${this.name}`);
    }
  }；

  return Person;
}())；

const me = new Person('Lee');
```

- ①에서 Person.prototype에 객체 리터럴을 할당.

  -  Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/e481635b-5520-4fb7-b835-f3fbb3f1917d">
</div>
   
- 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티 X.

  - constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티로,
 
  - me 객체의 생성자 함수 검색 시 Person이 아닌 Object가 나옴.

  ```jsx
  // 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결 파괴. 
  console.log(me.constructor === Person); // false
  
  // 프로토타입 체인을 따라 Object.prototyped constructor 
  console.log(me.constructor === Object); // true
  ```

- constructor 프로퍼티와 생성자 함수 간의 파괴된 연결 복원 방법은 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가함으로 해결 가능.

```jsx
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {

    // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
    constructor: Person,

    sayHe11o() {
      console.log(`Hi! My name is ${this.name}`);
    }
  }；

  return Person;
}())；

const me = new Person('Lee');
```

### 19.9.2 인스턴스에 의한 프로토타입의 교체

- 인스턴스의 `__proto__` 접근자 프로퍼티(or Object.setPrototypeOf 메서드)를 통해 프로토타입을 교체 가능.

  - **생성자 함수의 prototype 프로퍼티**에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것.

  - **`__proto__` 접근자 프로퍼티**를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것.

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  }
};

// ① me 객체의 프로토타입을 parent 객체로 교체.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작. 
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee
```

- ①에서 me 객체의 프로토타입을 parent 객체로 교체.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/9fdd4879-d75a-492c-8032-c94bad10bb6a">
</div>

- 19.9.1 "생성자 함수에 의한 프로토타입의 교체" 와 마찬가지로 constructor 프로퍼티 X.

  - 따라서, 프로토타입의 constructor 프로퍼티로 me 객체의 생성자 함수 검색 시 Person이 아닌 Object가 나옴.
 
  - 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체는 차이가 없어 보여도 미묘한 차이 존재.

  <div align="center">
    <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/545a9dec-cf6c-4f09-8f4d-6ad5edc90fcd">
  </div>

- 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가 후 생성자 함수의 prototype 프로퍼티를 재설정하여 생성자 함수와 프로토타입 간의 연결 복원 가능.

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {

  // constructor 프로퍼티와 생성자 함수 간의 연결을 설정 
  constructor: Person,

  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  }
};

// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결을 설정 
Person.prototype = parent;

// ① me 객체의 프로토타입을 parent 객체로 교체.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작. 
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee
```

- 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 번거롭기에 프로토타입의 직접 교체를 지양.

  - 상속 관계의 인위적인 설정은 19.11 "직접 상속"이 더 편리하고 안전.
 
  - ES6에서 도입된 25장 "클래스"를 사용하면 간편하고 직관적으로 상속 관계를 구현 가능.
 
## 19.10 instanceof 연산자

- 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받음.

  - 만약 우변의 피연산자가 함수가 아닌 경우 TypeError 발생.
 
    ```jsx
    객체 instanceof 생성자 함수
    ```
    
  - 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재 시 true로 평가，반대의 경우 false로 평가.

  ```jsx
  // 생성자 함수 
  function Person(name) {
    this.name = name;
  }
  
  const me = new Person('Lee');
  
  // Person.prototypeOl me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다. 
  console.log(me instanceof Person); // true
  
  // Object.prototypeOl me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다. 
  console.log(me instanceof Object); // true
  ```

-  instanceof 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아닌 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/31bc9064-7891-4cab-89c5-c9b8ecb9c4a9">
</div>

- me instanceof Person의 경우 me 객체의 프로토타입 체인 상에 Person.prototype에 바인딩된 객체가 존재 하는지 확인.

- instanceof 연산자를 함수로 표현하면 아래와 같은데,

  - 생성자 함수에 의해 프로토타입이 교체되어 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴 되어도

  - 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결은 파괴되지 않으므로 instanceof는 영향 X.

```jsx
function isInstanceof(instance, constructor) {
  // 프로토타입 취득
  const prototype = Object.getPrototypeOf(instance);

  // 재귀 탈출 조건
  // prototype이 null이면 프로토타입 체인의 종점에 다다른 것.
  if (prototype === null) return false;

  // 프로토타입이 생성자 함수의 prototype 프로퍼티에 바인딩된 객체라면 true를 반환. 
  // 그렇지 않다면 재귀 호출로 프로토타입 체인 상의 상위 프로토타압으로 이동하여 확인. 
  return prototype === constructor.prototype || isInstanceof(prototype, constructor); 
}

console.log(isInstanceof(me, Person)); // true
console.log(isInstanceof(me, Object)); // true
console.log(isInstanceof(me, Array));  // false
```

## 19.11 직접 상속

### 19.11.1  Object.create 에 의한 직접 상속

- Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성.

  - 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObjectCreate를 호출.
 
  - 첫 번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달.
 
  - 두 번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체를 전달.(옵션으로 생략 가능)
 
  ```jsx
  /**
  * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환.
  * @param {Object} prototype - 생성할 객체의 프로토타입으로 지정할 객체
  * @param {Object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체 
  * @returns {Object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체
  */
  Object.create(prototype[, propertiesObject])
  ```

```jsx
// 프로토타입이 null인 객처를 생성. 생성된 객체는 프로토타입 체인의 종점에 위치. 
// obj -> null
let obj = Object.create(nuUl);
console.log(Object.getPrototypeOf(obj) === null); // true
// Object. prototyped 상속 X.
console.log(obj.toString()); // Type Error: obj.toString is not a function

// obj -> Object.prototype -> null
// obj = {}; 와 동일.
obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// obj -> Object.prototype -> null
// obj = { x: 1 }; 와 동일.
obj = Object.create(Object.prototype, {
x: { value: 1, writable: true, enumerable: true, configurable: true } 
})；
// 위 코드는 아래와 동일.
// obj = Object.create(Object.prototype);
// obj.x = 1;
console.log(obj.x); // 1
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

const myProto = { x: 10 };
// 임의의 객체를 직접 상속 받음.
// obj -> myProto -> Object.prototype -» null
obj = Object.create(myProto);
console.log(obj.x); // 10
console.log(Object.getPrototypeOf(obj) === myProto); // true

// 생성자 함수
function Person(name) {
  this.name = name;
}

// obj -> Person.prototype -> Object.prototype -> null
// obj = new Person('Lee')와 동일.
obj = Object.create(Person.prototype);
obj.name = 'Lee';
console.log(obj.name); // Lee
console.log(Object.getPrototypeOf(obj) === Person.prototype); // true
```

- 객체를 생성하면서 직접적으로 상속을 구현하며, 장점은 아래와 같은데,

  1. new 연산자가 없이도 객체를 생성 가능.
 
  2. 프로토타입을 지정하면서 객체를 생성 가능.
 
  3. 객체 리터럴에 의해 생성된 객체도 상속 받음.

- ESLint에서는 앞의 예제와 같이 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장 X.

  - Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성 가능하기 때문.
 
  - 프로토타입 체인의 종점에 위치하는 객체는 Object.prototype의 빌트인 메서드를 사용 X.
 
  - 따라서 에러를 발생시킬 위험을 없애기 위해 Object.prototype의 빌트인 메서드는 간접 호출 권장.

  ```jsx
  // 프로토타입이 null인 객체를 생성.
  const obj = Object.create(null);
  obj.a = 1;
  
  // console.log(obj.hasOwnProperty('a')); -> TypeError: obj.hasOwnProperty is not a function
  
  // Object. prototyped 빌트인 메서드는 객체로 직접 호출 X. 
  console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true
  ```

### 19.11.2 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속

- ES6에서는 객체 리터럴 내부에서 `__proto__` 접근자 프로퍼티를 사용하여 직접 상속을 구현 가능.

  - Object.create 메서드에 의한 직접 상속은 앞에서 다룬 것과 같이 여러 장점 존재.
 
  - 하지만 두 번째 인자로 프로퍼티를 정의하는 것은 번거로움을 유발.
 
  - 먼저 객체를 생성한 이후 프로퍼티를 추가하는 방법도 있으나 이 또한 깔끔한 방법은 X.

```jsx
const myProto = { x: 10 };

// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속 받는 것이 가능. 
const obj = {
  y： 20,
  // 객체를 직접 상속받는다.
  // obj -> myProto -> Object.prototype -> null 
  __proto__: myProto
}；

/* 위 코드는 아래와 동일하다.
const obj = Object.create(myProto, { 
  y: { value: 20, writable: true, enumerable: true, configurable: true } 
})； 
*/

console.log(obj.x, obj.y); // 10 20 
console.log(Object.getPrototypeOf(obj) === myProto); // true
```




















































































