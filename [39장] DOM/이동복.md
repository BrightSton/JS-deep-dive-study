# 39장 DOM

> DOM은 HTML 문서의 계층적 구조와 정보를 표현하고 제어할 수 있는 API이다. <br>
> DOM은 프로퍼티와 메서드를 제공하는 트리 자료구조를 의미한다.

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

HTML 요소는 HTML 문서를 구성하는 개별적 요소를 의미한다.

![image](https://github.com/user-attachments/assets/b1c480af-1d58-4c08-a6bd-6e2c762e1054)


> HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다. <br>
> 어트리뷰트는 어튜리뷰트 노드로 변환된다. <br>
> 텍스트 콘텐츠는 텍스트 노드로 변환된다. <br>

![image](https://github.com/user-attachments/assets/9bd17013-e0e1-4a33-b27b-7725f400284f)


- HTML 문서는 HTML 요소들의 집합이며 중첩 관계를 갖는다.
- HTML 요소의 콘텐츠 영역에는 텍스트와 다른 HTML 요소도 포함될 수 있다.
- HTML 요소 간에는 중첩 관계로 계층적인 부자 관계가 형성되어 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료 구조로 구성한다.

#### 트리 자료구조

- 노드들의 계층 구조로 이뤄진다. (부모 노드와 자식 노드로 계층적 구조를 표현하는 비선형 자료구조)
- 하나의 최상위 노드로 시작하며 부모 노드가 없고 이를 루트 노드라고 한다.
- 루트 노드는 0개 이상의 자식 노드를 갖게 되면 자식 노드가 없는 노드를 리프 노드라 한다.

![image](https://github.com/user-attachments/assets/22db54ae-2cd3-48a2-bbec-5401059d9029)

노드 객체들로 구성된 트리 자료구조를 DOM, DOM 트리라고 한다.

### 39.1.2 노드 객체의 타입

HTML 문서를 렌더링 엔진이 파싱하면 렌더링 엔진은 HTML 문서를 파싱하여 DOM을 생성한다.

![image](https://github.com/user-attachments/assets/6b177cf3-8822-4954-bf6d-e7e7a18e807e)


	[공백 텍스트 노드]
	정확히는 위 그림에서 공백 텍스트 노드가 생략되어 있다.
	HTML 요소 사이의 개행이나 공백은 텍스트 노드가 된다.

DOM은 노드 객체의 계층적인 구조로 구성된다. 
노드 객체에는 종류가 있고 상속 구조를 갖는다 노드 객체는 총 12개의 종류(노드 타입)가 있다. <br>
여기서는 중요한 노드 타입 4가지를 살펴보자.

#### 문서 노드

- DOM 트리의 최상위에 존재하는 루트 노드로 document 객체를 가리킨다.
- document 객체는 브라우저가 렌더링한 HTML 문서 전체를 가르키며 전역 객체 window의 document 프로퍼티에 바인딩되어 있다.
- window.document 또는 document로 참조할 수 있다.
- 브라우저 환경의 모든 자바스크립트 코드는 분리된 script 태그여도 단 하나의 전역 객체 window를 공유한다.
- 모든 자바스크립트 코드는 전역 객체 window의 document 프로퍼티에 바인딩된 하나의 document를 바라본다
- DOM 트리의 루트 노드로 DOM 트리의 노드들에 접근을 위한 진입점 역할을 한다. 
- 따라서, 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다.

#### 요소 노드

- HTML 요소를 가리키는 객체로 HTML 요소 간의 중첩에 의해 부자 관계를 가지며, 이를 통해 정보를 구조화한다.
- 문서의 구조를 표현한다고 볼 수 있다.

#### 어트리뷰트 노드

- HTML 요소의 어트리뷰트 객체로 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어 있다.
- 단, 부모 노드와 연결되어 있지 않고 요소 노드에만 연결되어 있다.
- 부모 노드가 없어 요소 노드의 형제 노드는 아니다.
- 따라서, 어트리뷰트 노드에 접근하여 어트리뷰트를 참조하거나 변경하려면 먼저 요소 노드에 접근해야 한다.

#### 텍스트 노드

- HTML 요소의 텍스트를 가리키는 객체로 문서의 정보를 표현한다.
- 텍스트 노드는 요소 노드의 자식 노드이자 리프 노드이다.
- DOM 트리의 최종단으로 텍스트 노드에 접근하려면 부모 노드인 요소 노드에 접근해야 한다.

### 39.1.3 노드 객체의 상속 구조

- DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어 가능한 API(프로퍼티와 메서드를 제공하는 트리 자료구조)라고 한다.
- 즉, DOM을 구성하는 노드 객체는 자신의 구조와 정보를 제어하는 DOM API를 사용할 수 있다.

- DOM API를 통해 노드 객체는 자신의 부모, 형제, 자식을 탐색할 수 있고 자신의 어트리뷰트와 텍스트 조작이 가능하다.

- DOM을 구성하는 노드 객체는 브라우저 환경에서 추가적으로 제공하는 호스트 객체이다. 
- 노드 객체도 자바스크립트 객체로 프로토타입에 의한 상속 구조를 갖는다.

![image](https://github.com/user-attachments/assets/68d0c03d-7256-4f59-bf5a-b4604094ccf8)

위 그림처럼 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속받는다.

- 문서 노드는 Document, HTMLDocument 인터페이스를 상속받고 어트리뷰트 노드는 Attr, 텍스트 노드는 CharacterData 인터페이스를 각각 상속받는다.

- 요소 노드는 Element 인터페이스를 상속받는다. 또한 요소 노드는 추가적으로 HTMLElement와 태그의 종류별로 세분화된 HTMLHtmlElement, HTMLHeadElement, HTMLBodyElement, HTMLUListElement 등의 인터페이스를 상속받는다.

- 프로토타입 체인 관점에서는 input 요소를 파싱하여 객체화한 input 요소 노드 객체는 HTMLnputElement, HTMLElement, Element, Node, EventTarget, Object의 prototype에 바인딩되어 있는 프로토타입 객체를 상속받는다.
- 즉, input 요소 노드 객체는 프로토타입 체인에 있는 모든 프로토타입의 프로퍼티나 메서드를 상속받아 사용할 수 있다.

![image](https://github.com/user-attachments/assets/0f69f047-32c3-47ca-97d9-2d5f90da0449)

```html
<!DOCTYPE html>
<html>
<body>
  <input type="text">
  <script>
    // input 요소 노드 객체를 선택
    const $input = document.querySelector('input');

    // input 요소 노드 객체의 프로토타입 체인
    console.log(
      Object.getPrototypeOf($input) === HTMLInputElement.prototype,
      Object.getPrototypeOf(HTMLInputElement.prototype) === HTMLElement.prototype,
      Object.getPrototypeOf(HTMLElement.prototype) === Element.prototype,
      Object.getPrototypeOf(Element.prototype) === Node.prototype,
      Object.getPrototypeOf(Node.prototype) === EventTarget.prototype,
      Object.getPrototypeOf(EventTarget.prototype) === Object.prototype
    ); // 모두 true
  </script>
</body>
</html>
```

배열이 객체인 동시에 배열인 것처럼 input 요소 노드 객체도 다음과 같이 다양한 특성을 갖는 객체로 특성을 나타내는 기능들을 상속으로 제공받는다.

객체 -> Object <br>
이벤트 발생 객체 -> EventTarget <br>
트리 자료구조의 노드 객체 -> Node <br>
렌더링되는 웹 문서의 요소(HTML, XML, SVG)를 표현하는 객체 HTML 요소를 표현하는 객체 -> HTMLElement  <br>
input 요소를 표현하는 객체 -> HTMLInputElement <br> 

노드 타입에 상관없이 공통으로 갖는 노드 객체 기능과 노드 타입에 따라 고유한 기능을 가진다.

모든 노드 객체는 공동적으로 이벤트 발생이 가능하다.
이벤트 관련 기능(EventTarget.addEventlistener, EventTarget.removeEventListener 등)은 EventTarget 인터페이스가 제공한다.

모든 노드 객체는 트리 자료구조의 노드로 트리 탐색 기능, 노드 정보 제공 기능이 필요하다.
트리 탐색 기능(Node.parentNode, Node.childNodes, Node.previousSibling, Node.nextSibling 등) 노드 정보 제공 기능(Node.nodeType, Node.nodeNames 등)
위와 같은 노드 관련 기능은 Node 인터페이스가 제공한다.

HTML 요소가 객체화된 요소 노드 객체는 HTML 요소가 갖는 공통적인 기능이 있다.

input 요소 노드 객체와 div 요소 노트 객체는 모두 HTML 요소 스타일을 나타내는 style 프로퍼티가 있다.
이처럼 HTML 요소가 갖는 공통적 기능은 HTMLElement 인터페이스가 제공한다.

요소 노드 객체는 HTML 요소의 종류에 따라 고유한 기능도 있다.
예) input 요소 노드 객체는 value 프로퍼티를 갖는다. div 요소 노드 객체는 value 프로퍼티가 필요하지 않다

따라서 필요한 기능을 제공하는 인터페이스(HTMLinputElement. HTMLDivElement)가 HTML 요소의 종류에 따라 각각 다르다.
이처럼 노드 객체는 공통된 기능이면 프로토타입 체인의 상위, 개별적 고유 기능이면 하위에 포로토타입 체인을 구축하여 프로퍼티와 메서드를 제공하는 상속 구조를 갖는 DOM은 HTML 문서의 계증적 구조와 정보를 표현한다.

또한 노드 객체의 종류(노드 타입)에 따라 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공한다.
이 DOM API를 통해 HTML의 구조나 내용, 스타일 등을 동적으로 동작할 수 있다.

## 39.2 요소 노드 취득

- 요소 노드를 취득하여야 HTML 구조나 내용, 스타일을 동적으로 조작할 수 있다.
- 텍스트 노드는 요소 노드의 자식 노드이고, 어트리뷰트 노드는 요소 노드와 연결되어 있다.
- 예) HTML 문서 내 hl 요소의 텍스트를 변경한다면 DOM 트리 내의 h1 요소 노드를 취득하고 그 자식 노트인 텍스트 노드를 변경한다.

### 39.2.1 id를 이용한 노드 취득

- Document.prototype.getElementByld 메서드에 id 어트리뷰트 값을 인수로 전달한 하나의 요소 노드를 탐색하여 반환한다.
- getElementByld 메서드는 Document.prototpye의 프로퍼티이므로 Document 문서 노드를 반드시 호출하도록 한다.
- id 값은 HTML 문서 중 unique한 값으로 공백 문자로 구분해 여러 개의 값을 가질 수 없다.
- 중복된 id를 갖는 요소가 여러개 존재할 수 있는데 (에러 발생x) 이 경우 getElementByld의 인수인 id 값을 갖는 첫 요소 노드만 반환된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // id 값이 'banana'인 요소 노드를 탐색하여 반환한다.
      // 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.
      const $elem = document.getElementById('banana');

      // 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
      $elem.style.color = 'red';
    </script>
  </body>
</html>
```

인수로 전달된 id 값인 HTML 요소가 없으면 해당 메서드는 null 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="banana">Apple</li>
      <li id="banana">Banana</li>
      <li id="banana">Orange</li>
    </ul>
    <script>
      // getElementById 메서드는 언제나 단 하나의 요소 노드를 반환한다.
      // 첫 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.
      const $elem = document.getElementById('banana');

      // 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
      $elem.style.color = 'red';
    </script>
  </body>
</html>
```

HTML 요소에 id 어트리뷰트를 부여하면 id와 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 부수효과가 있다.
단 id 값과 동일한 이름의 전역 변수가 이미 선언되어 있다면 이 전역 변수에 노드 객체가 재할당되지 않는다.


### 39.2.2 태그 이름을 이용한 요소 노드 취득

Document.prototype / Element.prototype.getElementsByTagName 메서드는 인수로 전달된 태그 이름을 갖는 모든 요소 노드를 탐색 후 반환한다.
여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체 HTMLCollection 객체를 반환한다.

getElementsByTagName 메서드가 반환하는 DOM 컬렉션 객체인 HTMLCollection 객체는 유사 배열이면서 이터러블이다.

## 39-8 HTMLCollection

HTML 문서의 모든 요소를 취득할 때 인수로 '*'를 전달한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
      const $elem = document.getElementsByTagName('li');

      // HTMLCollection 객체를 배열로 변환하여 순회하면서 color 프로퍼티 값을 변경한다.
      [...$elem].forEach(elem => {
        elem.style.color = 'red';
      });
    </script>
  </body>
</html>
```

- getElementsByTagName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드가 있다.

- Document.prototype.getElementsByTagName 메서드는 DOM의 루프 노드인 문서 노드 (document)를 통해 호출하여 DOM 전체에서 요소 노드를 참색해 반환한다.
  
- 하지만 Element.prototype.getElementsByTagName 메서드는 특정 요소 노드를 통해 호출하고 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색해 반환한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange</li>
    </ul>
    <ul>
      <li>HTML</li>
    </ul>
    <script>
      // DOM 전체에서 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
      const $lisFromDocument = document.getElementsByTagName('li');
      console.log($lisFromDocument); // HTMLCollection(4) [li, li, li, li]

      // ul#fruits 요소의 자손 노드 중에서 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
      const $fruits = document.getElementById('fruits');
      const $lisFromFruits = $fruits.getElementsByTagName('li');
      console.log($lisFromDocument); // HTMLCollection(3) [li, li, li]
    </script>
  </body>
</html>
```

만약 인수로 전달된 태그 이름을 갖는 요소가 없는 경우 빈 HTMLCollection 객체를 반환한다.

### 39.2.3 class를 이용한 요소 노드 취득

- Document.prototype / Element.prototype.getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색 후 반환한다.
- 인수로 전달할 class 값은 공백으로 구분되어 여러 class 지정이 가능하다.
- 여러 개의 요소 노트 객체를 갖는 DOM 컬렉션 객체(HTMLCollection 객체)를 반환한다.

```html
const $elems = document.getElementsByClassName('fruit');
```

- getElementsByTagName 메서드와 같이 getElementsByclassName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드가 있다.
- Document.prototype.getElementsByClassName 메서드는 DOM의 루트 노드(문서 노드, document)로 호출된다.
- 그 후 DOM 전체에서 요소 노드를 탐색하여 반환하고 Element.prototype.getElementsByclassName 메서드는 특정 요소 노드로 호출하여 특정 요소 노드의 자손 노드 중 요소 노드를 탐색해 반환한다.

- 인수로 전달된 class 값을 갖는 요소가 없으면 getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환한다.

### 39.2.4 CSS 선택자를 이용한 요소 노드 취득

- CSS 선택자는 스타일을 적용할 때 HTML 요소를 특정할 때 사용하는 문법을 말한다.

- Document.prototype / Element.prototype.querySelector 메서드는 인수로 전달한 CSS 선택자를 만족하는 하나의 요소 노드를 탐색하고 반환한다.
- 인수로 전달한 CSS 선택자를 만족하는 요소 노드가 여럿이면 첫 번째 요소 노트만 반환한다.
- 인수로 전달된 CSS 선택자를 만족하는 요소 노드가 없으면 null을 반환한다.
- 인수로 전달한 CSS 선택자가 문법에 맞지 않으면 DOMException 에러가 발생

```html
const $elem = document.querySelector('.banana');
```

- Document.prototype / Element.prototype.querySelectorAll -> 인수로 전달한 CSS 선택자를 만족하는 모든 요소 노드를 탐색하여 반환한다.
- querySelectorAll 메서트는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체 NodeList 객체를 반환한다. NodeList 객체는 유사 배열 객체이면서 이터러블이다.
- 인수로 전달된 CSS 선택자를 만족시키는 요소가 없으면 빈 NodeList 객체 반환 인수로 전달한 CSS 선택자가 문법에 맞지 않으면 DOMException 에러 발생

```html
const $elems = document.querySelectorAll('ul > li');
```

HTML 문서의 모든 요소를 취득할 때 querySelectorAll 메서드의 인수로 선택자 '*'을 전달한다.

코드 예제 39-16

- getElementsByTagName / getElementsByclassName 메서드처럼 querySelector, querySelectorAll 메서드는 Document.prototype / Elementprotorype에 정의된 메서드가 있다.
- Document.prototype에 정의된 메서드는 DOM의 루트 노트(문서노드, document)를 통해 호출하고 DOM 전체에서 요소 노드를 탐색해 반환한다.
- Element.prototype에 정의된 메서드는 특정 요소 노드로 호출되며 특정 요소 노드의 자손 증 요소 노드를 탐색해 반환한다.
- CSS 선택자 문법을 사용하는 메서드 (querySelector, querySelectorAll)는 getElementByld, getElementBy*** 메서드보다 느리다.

하지만 CSS 선택자 문법으로 더 구체적인 조건 및 일관성 있는 방식으로 요소 노드 취득이 가능하다.

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

- ﻿﻿Element.prototype.matches 메서드는 인수로 전달한 CSS 선택자로 특정 요소를 취득할 수 있는지 확인한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      const $apple = document.querySelector('.apple');

      // $apple 노드는 #fruits > li.apple 로 취득할 수 있다.
      console.log($apple.matches('#fruits > li.apple')); // true

      // $apple 노드는 #fruits > li.banana 로 취득할 수 없다.
      console.log($apple.matches('#fruits > li.banana')); // false
    </script>
  </body>
</html>
```

### 39.2.6 HTMLCollection NodeList

- HTMLCollection과 NodeList는 DOM 컬렉션 객체로 DOM API가 여러 결과값을 반환하기 위한 DOM 컬렉션 객체이다.
- HTMLCollection과 NodeList는 유사 배열 객체이며 이터러블로 for.. of 문 및 스프레드 문법을 통해 배열로 변환할 수 있다.
- HTMLCollection과 NodeList는 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 객체이다.
- HTMLCollection은 언제나 live 객체(상태 변화 실시간 반영)로 등착한다.
- NodeList는 대부분 과거의 정적 상태를 유지하는 non-live 객체로 등작하지만 때로는 live 객체로 동작한다.

#### HTMLCollection

- getElementsByTagName, getElementsByClassName 메서드가 반환하는 HTMLCollection 객체는 live DOM 컬렉션 객체이다.

```html
<!DOCTYPE html>
  <head>
    <style>
      .red { color: red; }
      .blue { color: blue; }
    </style>
  </head>
<html>
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      // class 값이 red 인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
      const $elems = document.getElementsByClassName('red');
      // 이 시점에 HTMLCollection 객체에는 3개의 요소 노드가 담겨 있다.
      console.log($elems) // HTMLCollection(3) [li.red, li.red, li.red]

      // HTMLCollection 객체의 모든 요소의 class 값을 blue 로 변경한다.
      for (let i = 0; i < $elems.length; i++) {
        $elems[i].className = 'blue';
      }

      // HTMLCollection 객체의 요소가 3개에서 1개로 변경되었다.
      console.log($elems); // HTMLCollection(1) [li.red]
    </script>
  </body>
</html>
```

1. ﻿﻿﻿getElementsByClassName 메서드로 class 값이 'red'인 요소 노드 모두 취득
2. ﻿﻿﻿취득한 모든 요소 노드를 담은 HTMLCollection 객체를 순회하며,
3. ﻿﻿﻿className 프로퍼티를 사용해 모든 요소의 class 값을 'red'에서 'blue'로 변경 위 예제에서 li 요소의 class 값은 'blue'로 변경되고 모든 li 요소는 파란색으로 렌더링되어야 하지만 두번째 li 요소만 class 값이 변경되지 않는다.

![image](https://github.com/user-attachments/assets/f383b0d7-9d72-4d0d-bd26-dc599f74d8c4)
그림 39-9 예상대로 동작하지 않는다.

1. 첫 번째 반복(i === 0)
$elems[0]는 첫 번째 li 요소로 class 값이 'blue'로 변경된다.
getElementsByClassName 메서드의 인자로 전달된 'red'와 일치하지 않아 $elems에 실시간으로 제거된다.
이처럼 HTMLCollection 객체는 실시간으로 노드 객체의 상태 변경을 반영하는 살아 있는 DOM컬렉션 객체이다.

2. 두 번째 반복(i === 1)
$elems의 첫 번째 요소가 제거되어 length는 2이고 $elems[1]은 세 번째 li 요소를 가르킨다.
세 번째 li 요소의 class 값도 'blue'로 변경되고 HTMLCollection 객체인 $elems에서 실시간으로 제외된다.

3. 세 번째 반복(i === 2)
현재 $elems에는 두 번째 li 요소 노트만 남아 있어 $elems.length는 1이고 for문의 i는 2이므로 반복문이 종료된다.
따라서 $elems의 두 번째 요소의 class 값은 변경되지 않는다.

HTMLCollection 객체는 실시간으로 노드 객체의 상태 변경을 반영해 요소를 제거하므로 HTMLCollection 객체를 for문으로 순회하며 노드 객체의 상태 변경을 할 때는 주의해야 한다.

for문을 역으로 순회하여 이 문제를 해결하거나 while문으로 HTMLCollection 객체에 노드 객체가 남지 않을 때까지 반복하여 해결할 수 있다.

```html
// while 문으로 HTMLCollection에 요소가 남아 있지 않을 때까지 무한 반복
let i = 0;
while ($elems.length > i) {
  $elems[i].className = 'blue';
}
```

HTMLCollection을 사용하지 않음으로서 근본적으로 문제를 해결할 수 있다.
유사 배열 객체이면서 이터러블인 HTMLCollection 객체를 배열로 변환하면 유용한 배열의 고차함수까지 사용 가능하다.

```html
// 유사 배열 객체이면서 이터러블인 HTMLCollection을 배열로 변환하여 순회
[...$elems].forEach(elem => elem.className = 'blue');
```

#### NodeList

- HTMLCollection 객체의 부작용 해결을 위해 querySelectorAll 메서드를 사용할 수 있다.
- querySelectorAll 메서드는 DOM 컬렉션 객체 NodeList 객체를 반환한다.
- NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하지 않는 객체이다.

코드 예제 39-22

- NodeList 객체는 NodeList.prototype.forEach메서드를 상속받아 사용할 수 있다.
- NodeList의 forEach 메서드는 Array의 forEach와 사용법이 동일하다.
- NodeList 객체는 대부분의 경우 non-live 객체로 동작한다.
- 하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection 객체와 같이 live 객체로 동작한다.

<br>

- HTMLCollection이나 Nodelist 객체는 예상과 다르게 동작하는 경우가 많다.
- 노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하자.
- HTMLCollection과 NodeList 객체가 배열의 고차 함수만큼 다양한 기능을 제공하지는 않아 배열로 변환하는 것이 더 활용도가 높다.
- HTMLCollection과 NodeList 객체는 유사 배열 객체이면서 이터러블로 스프레드 문법이나 Array.from 메서드를 사용해 배열 변환이 가능하다.

## 39.3 노드 탐색

- 요소 노드 취득 후 요소 노드를 기점으로 DOM 트리의 부모, 형제, 자식 노드 탐색이 가능하다.

- DOM 트리 상의 노드를 탐색할 수 있게 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공한다.
- parentNode, previousSibling, frstchild, childNodes 프로퍼티는 Node.prototype이 제공한다.
- 프로퍼티 키에 Element가 포함된 PreviousElemersibling, nextElementSibling과 children 프로퍼티는 Element.prototype이 제공한다

- 노드 탐색 프로퍼티는 모두 접근자 프로퍼티다.
- 노드 탐색 프로퍼티는 getter만 존재하여 참조만 가능한 읽기 전용 접근자 프로퍼티이다.
- 따라서 읽기 전용 접근자 프로퍼티에 값을 할당하면 에러없이 무시된다.

## 39.3.1 공백 텍스트 노드

- HTML 요소 사이의 스페이스, 탭, 줄바꿈 등의 공백 문자는 텍스트 노드를 생성하고 이를 공백 텍스트 노드라고 한다.
- 텍스트 에디터에서 HTML 문서에 스페이스, 탭, 엔터 키 등을 입력하면 공백 문자가 추가된다.
- 노드를 탐색할 때 공백 문자가 생성한 공백 텍스트 노드에 주의해야 한다.

### 39.3.2 자식 노드 탐색

- 자식 노드를 탐색하기 위해 노드 탐색 프로퍼티를 사용한다.

![image](https://github.com/user-attachments/assets/c6f92da5-cc6c-496c-82be-56ab566af65a)

![image](https://github.com/user-attachments/assets/0a233542-b6dc-4983-ad50-ceae85ebba32)

### 39.3.3 자식 노드 존재 확인
- ﻿﻿Node.prototypehasChildNodes 메서드를 사용한다.
- 자식 노드가 존재하면 true 없으면 false를 반환한다.
- ﻿﻿hasChildNodes 메서드는 childNodes 프로퍼티와 같이 텍스트 노드를 포함하여 자식 노드의 존재를 확인한다.
- 자식 노드 중 요소 노드가 존재하는 지 확인할 때 children.length 또는 Element 인터페이스의 childElementCount 프로퍼티를 사용한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
    </ul>
    <script>
      // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
      const $fruits = document.getElementById('fruits');

      // #fruits 요소에 자식 노드가 존재하는지 확인한다.
      // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 노드의 존재 확인한다.
      console.log($fruits.hasChildNodes()); // true

      // 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지 확인한다.
      console.log(!!$fruits.children.length); // 0 -> false
      console.log(!!$fruits.childElementCount); // 0 -> false
    </script>
  </body>
</html>
```

### 39.3.4 요소 노드의 텍스트 노드 탐색

- 텍스트 노드는 요소 노드의 자식 노드이다.
- 따라서 frstChild 프로퍼티로 텍스트 노드의 접근이 가능하다.
- firstChild 프로퍼티는 첫 번째 자식 노드를 반환한다.
- firstChild 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드이다.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
    <script>
      // 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.
      console.log(document.getElementById('foo').firstChild); // #text
    </script>
  </body>
</html>
```

### 39.3.5 부모 노드 탐색

- Node.prototype.parentNode 프로퍼티로 부모 노드 탐색이 가능하다.
- 텍스트 노드는 DOM 트리의 최종단 노트인 리프 노드로 부모 노드가 텍스트 노드인 경우는 없다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // 노드 탐색의 기점이 되는 .banana 요소 노드를 취득한다.
      const $banana = document.querySelector('.banana');

      // .banana 요소 노드의 부모 노드를 탐색한다.
      console.log($banana.parentNode); // ul#fruits
    </script>
  </body>
</html>
```

### 39.3.6 형제 노드 탐색

- 형제 노드를 탐색할 때 다음과 같은 노드 탐색 프로퍼티를 사용한다.
- 어트리뷰트 노드는 요소 노드와 연결되었지만 부모 노드가 같은 형제 노드가 아니므로 반환되지 않는다.
- 즉, 아래 프로퍼티는 텍스트 노트 또는 요소 노드만 반환한다.

![image](https://github.com/user-attachments/assets/2038add3-8f71-482a-8b7a-3f279943fd97)

![image](https://github.com/user-attachments/assets/3d505e5b-e58e-4b95-99a6-2de86491270c)


## 39.4 노드 정보 취득

다음과 같은 노드 정보 프로퍼티로 노드 객체 정보를 취득한다.
![image](https://github.com/user-attachments/assets/9e8bb6d1-b927-4a88-8d3e-e0b28b1ab2b7)


## 39.5 요소 노드의 텍스트 조작

### 39.5.1 nodeValue

- Node.prototype.nodeValue 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티(참조, 할당 모두 가능)이다.
- 노드 객체의 nodeValue 프로퍼티를 참조하면 노드 객체의 값을 반환한다.
- 노드 객체의 값은 텍스트 노드의 텍스트이다.
- 텍스트 노드가 아닌 문서 노드나 요소 노드의 nodeValue 프로퍼티를 참조하면 null을 반환한다

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
    <script>
      // 문서 노드의 nodeValue 프로퍼티를 참조한다.
      console.log(document.nodeValue); // null

      // 요소 노드의 nodeValue 프로퍼티를 참조한다.
      const $foo = document.getElementById('foo');
      console.log($foo.nodeValue); // null

      // 텍스트 노드의 nodeValue 프로퍼티를 참조한다.
      const $textNode = $foo.firstChild;
      console.log($textNode.nodeValue); // Hello
    </script>
</html>
```

- 텍스트 노드의 nodeValue 프로퍼를 참조할 때만 텍스트 노드의 값(텍스트)를 반환한다.
- 텍스트 노드가 아닌 객체의 nodeValue 프로퍼티를 참조하면 null을 반환한다.
- 텍스트 노드의 nodeValue 프로퍼티에 값을 할당하면 텍스트 노드의 값인 텍스트 변경이 가능하므로 요소 노드의 텍스트를 변경할 때 다음의 순서를 따른다.

1. ﻿﻿﻿텍스트를 변경할 요소 노드를 취득하고 그 노드의 텍스트 노드를 탐색한다. 텍스트 노드는 요소 노드의 자식이므로 frstChild 프로퍼티로 탐색한다.
2. ﻿﻿﻿탐색한 노드의 nodeValue 프로퍼티를 사용해 텍스트 노드의 값을 변경한다.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
    <script>
      // 1. #foo 요소 노드의 자식 노드인 텍스트 노드를 취득한다.
      const $textNode = document.getElementById('foo').firstChild;

      // 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다.
      $textNode.nodeValue = 'World';

      console.log($textNode.nodeValue); // World
    </script>
</html>
```

### 39.5.2 textContent

- textContent 프로퍼티는 setter, getter를 갖는 접근자 프로퍼티로 요소 노드의 텍스트, 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.
- 요소 노드의 textContent 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내의 텍스트를 모두 반환한다.
- 즉, 요소 노드의 childNodes 프로퍼티가 반환한 모든 노드들의 텍스트 노드 값인 텍스르르 모두 반환하고 HTML 마크업은 무시된다.

```html
<!DOCTYPE html>
<html>
	<body>
  		<div id="foo">Hello <span>world!</span></div>
	</body>
	<script>
  		console.log(document.getElementById('foo').textContent); // Hello world!
	</script>
</html>
```

- nodeValue 프로퍼티를 참조해도 텍스트 취득이 가능하지만 텍스트 노드가 아닌 노드면 null을 반환하므로 의미가 없다.
- 텍스트 노드의 nodeValue 프로퍼티를 참조할 때만 텍스트를 반환한다.
- nodeValue 프로퍼티를 사용하면 textContent 프로퍼티를 사용할 때보다 더욱 복잡하다.

만약 요소 노드의 컨텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재하면 firstChild.nodeValue와 textContent 프로퍼티는 같은 결과를 반환한다.
이 경우 textContent 프로퍼티를 사용하는 코드가 더 간단하다.

요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다.
이 때 할당한 문자열에 HTML 마크업이 포함되어도 문자열 그대로 인식해 텍스트 취급된다. (HTML 마크업이 파싱되지 않음)

- textContent 프로퍼티와 유사한 동작을 하는 innerText 프로퍼티가 있지만 사용이 지양된다.
- innerText 프로퍼티는 CSS에 순종적으로 CSS에 의해 비표시(visibility: hidden;)이면 지정 요소 노드 텍스트를 반환하지 않음.
- innerText 프로퍼티는 CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다.

