# DOM

- DOM은 HTML 문서의 계층적 구조와 정보를 표현, 이를 제어할 수 있는 API로 프로퍼티와 메서드를 제공하는 트리 자료구조.
<br>

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

- **HTML 요소** : HTML 문서를 구성하는 개별적인 요소를 의미.

<div align="center">
  <img src="https://github.com/user-attachments/assets/0f4e1bc5-4ca0-4def-bb84-cc52299ea9c5">
</div>

-  HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환, 이때 요소의 어트리뷰트는 어트리뷰트 노드로, 요소의 텍스트 콘텐츠는 텍스트 노드로 변환.

<div align="center">
  <img src="https://github.com/user-attachments/assets/ca0fa8e1-4648-4767-8368-cb5cfc5fcd00">
</div>

- HTML 문서는 요소들의 집합으로 이루어져 중첩 관계를 가지는데, HTML 요소의 콘텐츠 영역에는 텍스트 뿐 아니라 다른 HTML 요소도 포함 가능.

- HTML 요소 간 중첩 관계에 의해 계층적인 부자관계가 형성되고 이러한 관계를 반영하여 HTML 문서의 구성 요소인 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료구조로 구성.

- **트리 자료구조**

  - 노드들의 계층 구조 즉, 부모 노드와 자식 노드로 구성되어 노드 간의 계층적 구조를 표현하는 비선형 자료구조를 지칭.
 
  - 하나의 최상위 노드(루트 노드)에서 시작 최상위는 부모 노드가 없으며, 0 ~ 2개 이상의 자식 노드(리프 노드)를 가짐.
 
  - 노드 객체들로 구성된 트리 자료구조가 DOM으로 노드 객체의 트리로 구조화되어 있기에 DOM 트리라 지칭.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/3123aeeb-008c-46b1-a181-69dad018664f">
  </div>
<br>

### 39.1.2 노드 객체의 타입

- 다음은 HTML 문서를 렌더링 엔진이 파싱하는 예시로.

```html
<!DOCTYPE html> 
<html>
  <head>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="style.css"> 
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li> 
      <li id="orange">0range</li> 
    </ul>
    <script src="app.js"x/script>
  </body>
</html>
```

- 렌더링 엔진은 위의 예시를 파싱하여 DOM을 생성.

<div align="center">
  <img src="https://github.com/user-attachments/assets/baa024c7-c836-4d43-bbd1-427efc44444b">
</div>

<div align="center">
  <img src="https://github.com/user-attachments/assets/38f1200e-68ca-49ef-a502-2af8479207b9">
</div>

- 노드 객체는 총 12 종류의 노드 타입이 있고, 그 중에서 중요한 노드 타입 4가지는 아래와 동일.

  - **문서 노드 document node**
 
    - DOM 트리의 최상위에 존재하는 루트 노드로 브라우저가 렌더링한 HTML 문서 전체를 가리키고 전역 객체 window의 document 프로퍼티에 바인딩 되어 존재.(window.document or document로 참조 가능)
   
    - 브라우저 환경의 모든 자바스크립트 코드는 script 태그에 의해 분리되어 있어도 하나의 전역 객체 window를 공유.(HTML 문서당 document 객체는 유일)
   
    - document 객체는 DOM 트리의 루트 노드로 다른 노드들에 접근을 위한 진입 역할로 요소, 어트리뷰트, 텍스트 노드에 접근 시 문서 노드를 통함.
   
  - **요소 노드 element node**
 
    - HTML 요소를 가리키는 객체로 요소 간의 중첩에 의해 부자 관계를 가지며, 부자 관계를 통해 정보를 구조화.(문서의 구조를 표현)
   
  - **어트리뷰트 노드 attribute node**  

    - HTML 요소의 어트리뷰트를 가리키는 객체로 어트리뷰트가 지정된 요소 노드와 연결, 부모 노드와 연결되어 있지 않고 요소 노드에만 연결.(요소 노드의 형제 노드 X)
   
    - 어트리뷰트 노드에 접근하여 어트리뷰트 참조 및 변경 시 요소 노드에 접근 필요.
   
  - **텍스트 노드 text node**
 
    - HTML 요소의 텍스트를 가리키는 객체로 문서 정보 표현, 요소 노드의 자식 노드이자 리프 노드로 DOM 트리의 최종단.
   
    - 텍스트 노드에 접근 시 부모 노드인 요소 노드에 접근 필요.
   
  - 외에도 주석을 위한 Comment 노드, DOCTYPE을 위한 DocumentType 노드, 복수의 노드를 생성하여 추가 시를 위한 DocumentFragment 노드 등 총 12개의 노드 타입 존재.
<br>

### 39.1.3 노드 객체의 상속 구조

- DOM은 HTML 문서의 계층적 구조와 정보를 표현하고, DOM을 구성하는 노드 객체는 자신의 구조와 정보를 제어할 수 있는 DOM API를 사용 가능.

- 노드 객체는 ECMAScript 사양에 정의된 표준 빌트인 객체가 아닌 브라우저 환경에서 추가적으로 제공하는 호스트 객체지만 노드 객체도 자바스크립트 객체로 프로토타입에 의한 상속 구조를 가짐.

<div align="center">
  <img src="https://github.com/user-attachments/assets/cd4d16d6-1341-40aa-b25b-adeea6b2beee">
</div>

- 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속받음.

  - 문서 노드는 Document, HTMLDocument 인터페이스를 상속.

  - 어트리뷰트 노드는 Attr를 상속.

  - 텍스트 노드는 CharacterData를 상속.
 
  - 요소 노드는 Element 인터페이스를 상속.(HTMLElement와 태그 종류별 HTMlHtmlElement, HTMLHeadElement, HTMLBodyElement, HTMLUListElement 상속)

- 프로토타입 체인 관점에서 input 요소 노드 객체는 프로토타입 체인에 있는 모든 프로토타입의 프로퍼티나 메서드를 상속받아 사용 가능.

<div align="center">
  <img src="https://github.com/user-attachments/assets/08257fc4-0c76-42e6-8231-ed879f9cc1f0">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <input type="text">
    <script>
      // input 요소 노드 객체를 선택 
      const $input = document.querySelector('input');

      // input 요소 노드 객체의 프로토타입 체인
      console.log(
        Object.getPrototypeOf($input) === HTMLInputElement.prototype,
        Object.getPrototypeOf(HTMLInputElement.prototype) === HTMLElement.prototype, 
        Object.getPrototypeOf(HTMLElement.prototype) === Element.prototype,
        Object.getPrototypeOf(Element.prototype) === Node.prototype, 
        Object.getPrototypeOf(Node.prototype) === EventTarget.prototype, 
        Object.getPrototypeOf(EventTarget.prototype) === Object.prototype 
      ); // 모두 true
    </script>
   </body>
</html>
```

- 배열이 객체인 동시에 배열인 것처럼 input 요소 노드 객체도 다양한 특성을 갖는 객체이며, 이러한 특성을 나타내는 기능들을 상속을 통해 제공.

<div align="center">
  <img src="https://github.com/user-attachments/assets/c5425f4f-7f85-4c83-bb48-1dbeae0dc457">
</div>

- 노드 객체의 상속 구조는 개발자 도구의 Elements 패널 우측의 Properties 패널에서 확인 가능.

<div align="center">
  <img src="https://github.com/user-attachments/assets/8c299981-f4af-4693-a96f-33a689a13d21">
</div>

- 노드 객체에는 노드 타입에 상관없이 모든 노드 객체가 공통으로 갖는 기능 및 노드 타입에 따른 고유한 기능도 존재.

  - **이벤트에 관련된 기능(EventTarget.addEventListener, EventTarget.removeEventListener 등)**
 
  - **트리 탐색 기능(Node.parentNode，Node.childNodes, Node.previousSibling, Node.nextSibling 등)**
 
  - **노드 정보 제공 기능(Node.nodeType, Node.nodeName 등)**

- 노드 객체는 공통된 기능일수록 프로토타입 체인의 상위에, 개별적인 고유 기능일수록 프로토타입 체인의 하위에 프로토타입 체인을 구축하여 노드 객체에 필요한 프로퍼티와 메서드를 제공하는 상속 구조.

- **DOM은 HTML 문서의 계층적 구조와 정보를 표현하는 것은 물론 노드 타입에 따과 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공.(HTML의 구조나 내용 or 스타일 등을 동적으로 조작 가능)**
<br>

## 39.2 요소 노드 취득

- HTML의 구조나 내용 또는 스타일 등을 등적으로 조작하려면 먼저 요소 노드를 취득 필요.

- 요소 노드의 취득은 HTML 요소를 조작하는 시작점으로 요소 노드를 취득할 수 있는 다양한 메서드를 제공.
<br>

### 39.2.1 id 를 이용한 요소 노드 취득

- Document.prototype.getElementByld 메서드는 인수로 전달한 id 어트리뷰트 값을 갖는 하나의 요소 노드를 탐색하여 반환.

- getElementByld 메서드는 Document.prototype의 프로퍼티로 반드시 문서 노드인 document를 통해 호출.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">0range</li>
    </ul>
    <script>
    // id 값이 'banana'인 요소 노드를 탐색하여 반환한다.
    // 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다. 
    const $elem = document.getElementById('banana');

    // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
    $elem.style.color = 'red';
    </script>
  </body>
</html> 
```

- id 값은 HTML 문서 내에서 유일한 값이지만 중복된 id 값을 갖는 HTML 요소가 여러 개 존재 시 에러 발생 X.

- id의 중복 존재 경우 getElementByld 메서드는 인수로 전달된 id 값을 갖는 첫 번째 요소 노드만 반환.

```html
<!DOCTYPE html>
<html>
  <body>
     <ul>
       <li id="banana">Apple</li>
       <li id="banana">Banana</li>
       <li id="banana">0range</li>
     </ul>
     <script>
      // getElementByld 메서드는 언제나 단 하나의 요소 노드를 반환한다.
      // 첫 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다. 
      const $elem = document.getElementById('banana');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      $elem.style.color = 'red';
     </script>
  </body>
</html> 
```

- 인수로 전달된 id 값을 갖는 HTML 요소가 존재하지 않는 경우 getElementByld 메서드는 nuU을 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">0range</li>
    </ul>
    <script>
      // id 값이 'grape'21 요소 노드를 탐색하여 반환한다. nullO/ 반환된다. 
      const $elem = document.getElementById('grape');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다.
      $elem.style.color = 'red';
      // — TypeError: Cannot read property 'style' of null 
    </script> 
  </body>
</html> 
```

- HTML 요소에 id 어트리뷰트를 부여하면 id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 부수 효과 존재.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo"></div>
    <script>
      // id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당된다.
      console.log(foo === document.getElementById('foo')); // true
      // 암묵적 전역으로 생성된 전역 프로퍼티는 삭제되지만 전역 변수는 삭제되지 않는다.
      delete foo;
      console.log(foo); // <div id="foo"></div>
    </script>
  </body>
</html> 
```

- 단，id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 이 전역 변수에 노드 객체 재할당 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo"></div>
    <script>
      let foo = 1;
      // id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 노드 객체가 재할당되지 않는다. 
      console.log(foo); // 1
    </script>
  </body>
</html> 
```
<br>

### 39.2.2 태그 이름을 이용한 요소 노드 취득

- Document. prototype/Element.prototype.getElementsByTagName 메서드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환.

- getElementsByTagName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
      // 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환된다.
      // HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
      const $etems = document.getElementsByTagName('li');
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다.
      // HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경한다. 
      [... $elems].forEach(elem => { elem.style.color = 'red'; }); 
    </script>
  </body>
</html> 
```

- getElementsByTagName 메서드가 반환하는 DOM 컬렉션 객체인 HTMLCollection 객체는 유사 배열 객체이면서 이터러블.

<div align="center">
  <img src="https://github.com/user-attachments/assets/9c36130b-f8a1-4c91-9c5c-c109781c273b">
</div>

- HTML 문서의 모든 요소 노드를 취득하려면 getElementsByTagName 메서드의 인수로 를 전달.

<div align="center">
  <img src="https://github.com/user-attachments/assets/02670867-9648-4b76-8fe9-11eb13dd2a84">
</div>

- getElementsByTagName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드 whswo.

  - Document.prototype.getElementsByTagName 메서드 : DOM의 루트 노드인 문서 노드를 통해 호출하며 DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype.getElementsByTagName 메서드 : 특정 요소 노드를 통해 호출하며, 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
      <1i>0range</1i>
    </ul>
    <ul>
      <U>HTML</1i>
    </ul>
    <script>
      // DOM 전체에서 태그 이름이 난인 요소 노드를 모두 탐색하여 반환한다.
      const $lisFromDocument = document.getElementsByTagName('li'); 
      console.log($lisFromDocument); // HTMLCollection(A) [li, li, li, li]
      // ulfffruits 요소의 자손 노드 중에서 태그 이름이 선인 요소 노드를 모두 탐색하여 반환한다.
      const $fruits = document.getElementById('fruits');
      const $lisFromFruits : $fruits.getElementsByTagName('li'); 
      console.log($lisFromFruits); // HTMLCollection(3) [li, li, li] 
    </script>
  </body>
</html> 
```

- 만약 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우 getElementsByTagName 메서드는 빈 HTMLCollection 객체를 반환.
<br>

### 39.2.3 class를 이용한 요소 노드 취득

- Document.prototype/Element.prototype.getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환.

- 인수로 전달할 class 값은 공백으로 구분하여 여러 개의 class를 지정 가능하고 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="fruit apple">App1e</_li>
      <li class="fruit banana">Banana</li>
      <li class="fruit orange">Orange</li>
    </ul>
    <script>
      // class 값이 'fruit'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다. 
      const $elems = document.getElementsByClassName('fruit');
      // 화득한 모든 요소의 CSS color 프로퍼티 값을 변경한다.
      [... $elems].forEach(elem => { elem.style.color = 'red'; });
      // class 값이 'fruit apple'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다. 
      const $apples = document.getElementsByClassName('fruit apple');
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      [... $apples].forEach(elem => { elem.style.color = 'blue'; }); 
    </script>
  </body>
</html> 
```

- getElementsByClassName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드 존재.

  - Document.prototype.getElementsByClassName 메서드 : DOM의 루트 노드인 문서 노드를 통해 호출하며 DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype.getElementsByClassName 메서드 : 특정 요소 노드를 통해 호출하며 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <div class="banana">Banana</div>
    <script>
      // DOM 전체에서 class 값01 'banana'인 요소 노드를 모두 탐색하여 반환한다. 
      const $bananasFromDocument = document.getElementsByClassName('banana'); 
      console.log($bananasFromDocument); 
      // HTMLCollection(2) [Ii.banana, div.banana]
      // ttfruits 요소의 자손 노드 중에서 class 값이 'banana'인 요소 노드를 모두 탐색하여 반환한다. 
      const $fruits = document.getElementById('fruits');
      const $bananasFromFruits = $fruits.getElementsByClassName('banana');
      console.log($bananasFromFruits); // HTMLCollection [li.banana] 
    </script>
  </body>
</html> 
```

- 인수로 전달된 class 값을 갖는 요소가 존재하지 않는 경우 getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환.
<br>

### 39.2.4 CSS 선택자를 이용한 요소 노드 취득

- CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법.

```css
/* 전체 선택자: 모든 요소를 선택 */
* { ... }
/* 태그 선택자: 모든 p 태그 요소를 모두 선택 */
P { ... }
/* id 선택자: id 값이 'foo'인 요소를 모두 선택 */
#foo { ... }
/* class 선택자: class 값이 'foo'인 요소를 모두 선택 */
.foo { ... }
/* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 'text'인 요소를 모두 선택 */ 
input[type=text] { ... }
/* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */ 
div p { ... }
/* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */
div > p { ... }
/* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */ 
p + ul { ... }
/* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */ 
p ~ ul { ... }
/* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */ 
a:hover { ... }
/* 가상 요소 선택자: p 요소의 콘텐츠의 앞에 위치하는 공간을 선택
  일반적으로 content 프로퍼티와 함께 사용된다. */ 
p:: before { ... }
```

- Document.prototype/Element.prototype.queryselector 메서드는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환.

  - 안수로 전달한 CSS 선택자를 만족시키는 요소 노드가 여러 개인 경우 첫 번째 요소 노드만 반환.
 
  - 안수로 전달된 CSS 선택자를 만족시키는 요소 노드가 존재하지 않는 경우 null을 반환.
 
  - 안수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // class 어트리뷰트 값이 'banana'인 첫 번째 요소 노드를 탐색하여 반환한다. 
      const $elem = document.querySelector('.banana');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      $elem.style.color = 'red';
    </script>
  </body>
</html> 
```

- querySelectorAll 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 NodeList 객체를 반환.(유사 배열 & 이터러블)

  - 안수로 전달된 CSS 선택자를 만족시키는 요소가 존재하지 않는 경우 빈 NodeList 객체를 반환.
 
  - 안수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // ul 요소의 자식 요소인 요소를 모두 탐색하여 반환한다.
      const $elems = document.querySelectorAll('ul > li');
      // 취득한 요소 노드들은 NodeList 객체에 담겨 반환된다. 
      console.log($elems); // NodeList(3) [li.apple, li.banana, li.orange]
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      // IVodeList 는 for Each 메서드를 제공한다.
      $elems.forEach(elem => { elem.style.color = 'red'; }); 
    </script>
  </body>
</html> 
```
 
- HTML 문서의 모든요소노드를취득하려면 querySelectorAU 메서드의 인수로 전체 선택자 를 전달.

```js
// 모든 요소 노드를 탐색하여 반환한다.
const $all = document.querySelectorAll('*');
// — NodeList(8) [html, head, body, ul, liitapple, liltbanana, lifforange, script]
```

- queryselector, querySelectorAll 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드에 존재.

  - Document.prototype에 정의된 메서드는 DOM의 루트 노드인 문서 노드를 통해 호출하며, DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype에 정의된 메서드는 특정 요소 노드를 통해 호출하며 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.
 
- CSS 선택자 문법을 사용하는 queryselector, querySelectorAll 메서드는 getElementByld, getElementsBy*** 메서드보다 다소 느린 것으로 알려져 있지만 구체적인 조건으로 요소 노드를 취득할 수 있고 일관된 방식으로 요소 노드를 취득할 수 있다는 장점 존재.

- 따라서, **id 어트리뷰트가 있는 요소 노드를 취득하는 경우에는 getElementByld 메서드를 사용하고 그 외의 경우에는 queryselector, querySelectorAll 메서드를 사용하는 것을 권장.**
<br>

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

- Element.prototype.matches 메서드는 인수로 전달한 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Appl.e</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    const $apple = document.querySelector('.apple');
    // $apple 노드는 '#fruits > li.apple’로 취득할 수 있다. 
    console.log($apple.matches('#fruits > li.apple')); // true
    // $apple 노드는 '#fruits > li.banana’로 취득할 수 없다. 
    console.log($apple.matches('fffruits > li.banana')); // false 
  </script>
</html> 
```

- Element.prototype.matches 메서드는 이벤트 위임을 사용할 때 유용.
<br>

### 39.2.6 HTMLCollection 과 NodeList

- DOM 컬렉션 객체인 HTMLCoUection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체로 유사 배열 객체 & 이터러블이여서 for... of 문으로 순회 및 스프레드 문법 사용 가능.

- 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 객체.

  - HTMLCollection은 언제나 live 객체로 동작.

  - NodeList는 대부분의 경우 노드 객체의 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작.(경우에 따라 live 객체로 동작)

- **HTMLCollection**

  -  getElementsByTagName, getElementsByClassName 메서드가 반환하는 HTMLCoUection 객체는 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 DOM 컬렉션 객체.(살아있는 객체)

  ```html
  <!DOCTYPE html>
  <head>
    <style>
      .red { color: red; }
      .blue { color: blue; }
    </style>
  </head>
  <html>
    <body>
      <ul id="fruits">
        <li class="red">Apple</li>
        <li class="red">Banana</li>
        <li class="red">Orange</li>
      </ul>
      <script>
        // class 값이 'red'인 요소 노드를 모두 탐색하여 HTMLCoUection 객체에 담아 반환한다. 
        const $elems = document.getElementsByClassName('red');
        // 이 시점에 HTMLCoUection 객체에는 3개의 요소 노드가 담겨 있다. 
        console.log($elems); // HTMLCollection(3) [li.red, li.red, li.red]
        // HTMLCollection 객체의 모든 요소의 class 값을 'blue'로 변경한다. 
        for (let i = 0; i < $elems.length; i++) { 
          $elems[i].className = 'blue'; 
        }
        // HTMLCollection 객체의 요소가 3개에서 1 개로 변경되었다. 
        console.log($elems); // HTMLCollection [li.red] 
      </script>
    </body>
  </html>
  ```
  
  - 위 예제가 에러 없이 실행되면 모든 li 요소의 class 값이 'blue'로 변경, 모든 li 요소는 CSS에 의해 파란색으로 렌더링 되어야 하지만 두 번째 li 요소만 class 값이 변경.
  
  <div align="center">
    <img src="https://github.com/user-attachments/assets/b6946030-ceca-4f2d-8d64-51f86ce8b163">
  </div>
  
  - 예상대로 동작하지 않은 이유를 알아보자면, $elems.length는 3으로 for 문의 코드 블록은 3번 반복.
  
  <div align="center">
    <img src="https://github.com/user-attachments/assets/fe95eb91-49bb-4a95-9b82-691760dd2e2d">
  </div>
  
  - HTMLCollection 객체는 실시간으로 노드 객체의 상태 변경을 반영하여 요소 제거가 가능하기에 for 문으로 순회하면서 노드 객체의 상태를 변경해야 할 때 주의 필요.
  
  - 위의 문제는 for 문을 역방향으로 순회하는 방법으로 회피 가능.
  
  ```js
  // for 문을 역방향으로 순회
  for (let i = $elems.length - 1; i >= 0; i--) { 
    $elems[i].className = 'blue';
  }
  ```
  
  - 또는 while 문을 사용하여 HTMLCollection 객체에 노드 객체가 남아 있지 않을 때까지 무한 반복하는 방법으로 회피 가능.
  
  ```js
  // while 문으로 HTMLCollection에 요소가 남아 있지 않을 때까지 무한 반복 
  let i = 0;
  while ($elems.length > i) {
    $elems[i].className = 'blue';
  }
  ```
  
  - 제일 간단한 해결책은 부작용을 발생시키는 원인인 유사 배열 객체이면서 이터러블인 HTMLCollection 객체를 배열로 변환 시 유용한 배열의 고차 함수 사용 가능.
  
  ```js
  // 유사 배열 객체이면서 이터러블인 HTMLCollection^ 배열로 변환하여 순회
  [ ... $elems].forEach(elem => elem.cIassName = 'blue');
  ```

- **NodeList**

  - HTMLCollection 객체의 부작용 해결로 querySelectorAll 메서드를 사용하는 것으로 DOM 컬렉션 객체인 NodeList 객체를 반환.(실시간으로 노드 객체의 상태 변경을 반영하지 않는 객체)

  ```js
  // querySelectorAll은 DOM 컬렉션 객체인 NodeList를 반환한다.
  const $elems = document.querySelectorAll('.red');
  
  // NodeList 객체는 NodeList. prototype. forEach 메서드를 상속받아 사용할 수 있다.
  $elems.forEach(elem => elem.className = 'blue');
  ```
   
  - querySelect이'All이 반환히는 NodeList 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용 가능.
  
  - NodeList 객체는 대부분 non-live 객체로 동작하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의가 필요.
  
  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
      <1i>Apple</1i>
      <1i>Banana</1i>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');
  
      // childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.
      const { childNodes } = $fruits; 
      console.log(childNodes instanceof NodeList); // true
  
      // $ fruits 요소의 자식 노드는 공백 렉스트 노드 (39.3.1 절 "공백 텍스트 노드" 참고)를 
      // 포함해 모두 5개다. 
      console.log(childNodes); // NodeList(5) [text, li, text, li, text]
  
      for (let i = 0; i < childNodes.length; i++) { 
        // removechild 메서드는 $ fruits 요소의 자식 노드를 DOM에서 삭제한다. 
        // (39.6.9절 "노드 삭제" 참고)
        // removechild 메서드가 을M 때마다 NodeList 객체인 childNodes가 실시간으로 
        // 따라서 첫 번째，세 번째, 다섯 번째 요소만 삭제된다. 
        $fruits.removeChild(childNodes[i]); 
      }
      // 예상과 다르게 $fruits 요소의 모든 자식 노드가 삭제되지 않는다. 
      console.log(childNodes); // NodeList(2) [li, li]
    </script>
  </html>
  ```
  
  - 노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장.
  
  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
      <1i>Apple</1i>
      <1i>Banana</1i>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');
  
      // childNodes 프로퍼티는 NodeList 객체(live)를 반환한다. 
      const { childNodes } = $fruits;
  
      // 스프러/드 문법을 사용하여 NodeList 객체를 배열로 변환한다. 
      [... childNodes].forEach(childNode => { 
        $fruits.removeChild(childNode); 
      })；
  
      // $ fruits 요소의 모든 자식 노드가 모두 삭제되었다. 
      console.log(childNodes); // NodeList [] 
    </script>
  </html>
  ```
<br>

## 39.3 노드 탐색

- 요소 노드 취득 후 DOM 트리의 노드를 옮겨 다니며 부모, 형제, 자식 노드등을 탐색 필요 시 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공.

<div align="center">
  <img src="https://github.com/user-attachments/assets/abd7a103-3c7d-4309-a348-222e9e664887">
</div>

- parentNode, previousSibling, firstChild, childNodes 프로퍼티는 Node.prototype이 제공, 프로퍼티키에 Element가 포함된 previousElementSibling, nextElementSibling과 children 프로퍼티는 Element.prototype이 제공.

- 노드 탐색 프로퍼티는 모두 접근자 프로퍼티지만 노드 탐색 프로퍼티는 setter없이 getter만 존재하여 참조만 가능한 읽기 전용 접근자 프로퍼티로 값 할당 시 에러 없이 무시.

<div align="center">
  <img src="https://github.com/user-attachments/assets/65eeca76-1603-472d-a21f-dc7bf06a08ab">
</div>
<br>

### 39.3.1 공백 텍스트 노드

- HTML 요소 사이의 스페이스, 탭, 줄바꿈 등의 공백 문자는 텍스트 노드를 생성.(공백 텍스트 노드)

```html
<!DOCTYPE htm1>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
</html>
```

- 텍스트 에디터에서 HTML 문서에 스페이스 키, 랩 키, 엔터 키 등을 입력하면 공백 문자가 추가되고 위 HTML 문서는 파싱되어 아래와 같은 DOM을 생성.

<div align="center">
  <img src="https://github.com/user-attachments/assets/c706ae3f-4574-45cc-8c5b-b0dead0a9f7c">
</div>

- 노드 탐색 시 공백 문자가 생성한 공백 텍스트 노드에 주의 필요, 아래와 같이 인위적으로 공백 문자 제거 시 공백 텍스트 노드를 생성하지 않지만 가독성이 좋지 않으므로 권장 X.

```html
<ul id="fruits"><li
 class="apple">App1e</1i><1i
 class=" banana">Banana</Li><Li
 class="orange">Orange</li></ul>
```
<br>

### 39.3.2 자식 노드 탐색

- 자식 노드를 탐색하기 위해서는 다음과 같은 노드 탐색 프로퍼티를 사용.

<div align="center">
  <img src="https://github.com/user-attachments/assets/e0888a58-14ab-4518-a31e-d0005f08a813">
  <img src="https://github.com/user-attachments/assets/a95dd0fd-354b-411b-bb8d-15ded18e9f65">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li> 
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 ^fruits 요소 노드를 취득한다. 
    const $fruits = document.getElementById('fruits');

    // #fruits 요소의 모든 자식 노드를 탐색한다.
    // childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있다. 
    console.log($fruits.childNodes);
    // NodeList(7) [text, li.apple, text, li.banana, text, li.orange, text]

    // fruits 요소의 모든 자식 노드를 탐색한다.
    // children 프로퍼티가 반환한 HTMLCollection에는 요소 노드만 포함되어 있다. 
    console.log($fruits.children);
    // HTMLCollection(3) [li.apple, li.banana, li.orange]

    // fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstChild 프로퍼티는 텍스트 노드를 반환할 수도 있다. 
    console.log($fruits.firstChild); // #text

    // fruits 요소의 마지막 자식 노드를 탐색한다.
    // lastchild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
    console.log($fruits.lastchild); // #text

    // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstElementChild 프로퍼티는 요소 노드만 반환한다. 
    console.log($fruits.firstElementchild); // li.apple

    // #fruits 요소의 마지막 자식 노드를 탐색한다.
    // lastElementChild 프로퍼티는 요소 노드만 반환한다. 
    console.log($fruits.lastElementchild); // li.orange 
  </script>
</html>
```
<br>

### 39.3.3 자식 노드 존재 확인

- 자식 노드가 존재하는지 확인하려면 Node.prototype.hasChildNodes 메서드를 사용, 자식 노드가 존재 유무에 따라 true/false 반환.(텍스트 노드를 포함하여 자식 노드의 존재를 확인)

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 //fruits 요소 노드를 취득한다.
    const $fruits = document.getElementById('fruits');
    // it fruits 요소에 자식 노드가 존재하는지 확인한다.
    // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 누드의 존재를 확인한다.
    console.log($fruits.hasChildNodes()); // true
  </script>
</html>
```

- 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인하려면 children.length or Element 인터페이스의 childElementCount 프로퍼티를 사용.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
    const $fruits = document.getElementById('fruits');

    // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 누드의 존재를 확인한다.
    console.log($fruits.hasChildNodes()); // true

    // 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인한다. 
    console.log(!!$fruits.children.length); // 0 — false 

    // 자식 노드 중에 렉스트 노드가 아닌 요소 노드가 존재하는자는 확인한다. 
    console.log(!!$fruits.childElementCount); // 0 — false 
  </script>
</html>
```
<br>

### 39.3.4 요소 노드의 텍스트 노드 탐색

- 요소 노드의 텍스트 노드는 요소 노드의 자식 노드로 firstChild 프로퍼티로 접근 가능하고 첫 번째 자식 노드를 반환, 반환한 노드는 텍스트 노드 or 요소 노드.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
    <script>
      // 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.
      console.log(document.getElementById('foo').firstChild); // #text
    </script>
  </body>
</html>
```
<br>

### 39.3.5 부모 노드 탐색

- 부모 노드를 탐색하려면 Node.prototype.parentNode 프로퍼티를 사용하고 텍스트 노드는 DOM 트리의 최종단 노드인 리프 노드로 부모 노드가 텍스트 노드인 경우 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 .banana 요소 노드를 취득한다.
    const $banana = document.querySelector('.banana');

    // .banana 요소 노드의 부모 노드를 탐색한다.
    console.log($banana.parentNode); // ul#fruits
  </script>
</html>
```
<br>

### 39.3.6 형제 노드 탐색

- 부모 노드가 같은 형제 노드 탐색 시 아래과 같은 노드 탐색 프로퍼티를 사용하지만 어트리뷰트 노드는 요소 노드와 연결되어 있지만 부모 노드가 같은 형제 노드가 아니기에 반환 X.(텍스트 노드 or 요소 노드만 반환)

<div align="center">
  <img src="https://github.com/user-attachments/assets/34bc8e1b-a7de-4019-907d-58c4eb9ba27f">
  <img src="https://github.com/user-attachments/assets/a6240764-d3cb-4bbd-a4a3-2aeb7e9562b7">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li> 
      <li class="banana">Banana</li> 
      <li class="orange">Orange</li> 
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다. 
    const $fruits = document.getElementById('fruits');
    
    // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstChild 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { firstChild } = $fruits; 
    console.log(firstChild); // ittext

    // #fruits 요소의 첫 번째 자식 노드(텍스트 노드)의 다음 형제 노드를 탐색한다. 
    // nextSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { nextSibling } = firstChild; 
    console.log(nextSibling); // li.apple

    // li.apple 요소의 이전 형제 노드를 탐색한다.
    // previousSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { previousSibling } = nextSibling;
    console.log(previousSibling); // #text

    // #fruits 요소의 첫 번째 자식 요소 노드를 탐색한다.
    // firstElementChild 프로퍼티는 요소 노드만 반환한다. 
    const { firstElementChild } = $fruits; 
    console.log(firstElementchild); // li.apple

    // #fruits 요소의 첫 번째 자식 요소 노드(li.apple)의 다음 형제 노드를 탐색한다. 
    // nextElementSibling 프로퍼티는 요소 노드만 반환한다.
    const { nextElementSibling } = firstElementchild; 
    console.log(nextElementSibling); // li.banana

    // li.banana 요소의 이전 형제 요소 노드를 탐색한다.
    // previousElementSibling 프로퍼티는 요소 노드만 반환한다. 
    const { previousElementSibling } = nextElementSibling; 
    console.log(previousElementSibling); // li.apple 
  </script>
</html>
```
<br>

## 39.4 노드 정보 취득

- 노드 객체에 대한 정보를 취득하려면 다음과 같은 노드 정보 프로퍼티를 사용.

<div align="center">
  <img src="https://github.com/user-attachments/assets/eb009cd9-d421-418c-ade5-14d1e8cb6773">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
  <script>
    // 문서 노드의 노드 정보를 취득한다.
    console.log(document.nodeType); // 9 
    console.log(document.nodeName); // itdocument

    // 요소 노드의 노드 정보를 취득한다.
    const $foo = document.getElementById('foo'); 
    console.log($foo.nodeType); // 1 
    console.log($foo.nodeName); // DIV

    // 텍스트 노드의 노드 정보를 취득한다.
    const $textNode = $foo.firstChild;
    console.log($textNode.nodeType); // 3 
    console. log($textNode.nodeName); // it text 
  </script>
</html>
```
<br>

## 39.5 요소 드의 텍스트 조작

### 39.5.1 nodeValue

- Node.prototype.nodeValue 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로 참조와 할당 모두 가능.

- 노드 객체의 nodeValue 프로퍼티 참조 시 노드 객체의 값을 반환, 텍스트 노드의 텍스트로 문서 노드나 요소 노드의 nodeValue 프로퍼티 참조 시 null을 반환.

```html
<!DOCTYPE htm1>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
  <script>
    // 문서 노드의 nodeValue 프로퍼티를 참조한다.
    console.log(document.nodeValue); // null

    // 요소 노드의 nodeValue 프로퍼티를 참조한다.
    const $foo = document.getElementById('foo');
    console.log($foo.nodeValue); // null

    // 텍스트 노드의 nodeValue 프로퍼티를 참조한다.
    const $textNode = $foo.firstChild;
    console.log($textNode.nodeValue); // Hello
  </script>
</html>
```

- 텍스트 노드의 nodevalue 프로퍼티에 값을 할당하면 텍스트 변경 가능함으로 요소 노드의 텍스트 변경 시 아래와 같은 순서가 필요.

  - 텍스트를 변경할 요소 노드 취득 후, 취득한 요소 노드의 텍스트 노드를 탐색, 요소 노드의 자식 노드이므로 firstChild 프로퍼티를 사용하여 탐색.
 
  - 탐색한 텍스트 노드의 nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경.

```html
<!DOCTYPE html>
<html> 
  <body>
    <div id="foo">He11o</div>
  </body>
  <script>
    // 1. ttfoo 요소 노드의 자식 노드인 텍스트 노드를 취득한다. 
    const $textNode = document.getElementById('foo').firstChild;

    // 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다. 
    $textNode.nodeValue = 'World';
    console.log($textNode.nodeValue); // World
  </script>
</html>
```
<br>

### 39.5.2 textcontent

- Node.prototype.textcontent 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득 or 변경.

- 요소 노드의 textcontent 프로퍼티 참조 시 요소 노드의 콘텐츠 영역 내의 텍스트를 모두 반환.(HTML 마크업은 무시)

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // fffoo 요소 노드의 텍스트를 모두 취득한다. 이때 HTML 마크업은 무시된다.
    console.log(document.getElementById('foo').textcontent); // Hello world! 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/33f2d6de-b27e-49a3-aaf2-3650f8977aab">
</div>

- nodevalue 프로퍼티 참조 시 텍스트 취득 가능하고 텍스트 노드의 nodeValue 프로퍼티를 참조 시만 텍스트 반환, 다만 textcontent 프로퍼티 사용 시 보다 복잡한 코드 생성.

```html
<!DOCTYPE htm1>
<html>
  <body> 
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // ttfoo 요소 노드는 텍스트 노드가 아니다.
    console.log(document.getElementById('foo').nodeValue); // null 

    // itfoo 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다. 
    console.log(document.getElementById('foo').firstChild.nodeValue); // Hello 

    // span 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다. 
    console.log(document.getElementById('foo').lastchild.firstChild.nodeValue); // world! 
  </script> 
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/d53b94e1-1a3e-4a57-82df-b83c2836fa55">
</div>

- 만약 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재 시 textcontent 프로퍼티를 사용하면 더 간단한 코드 생성.

```html
<!DOCTYPE html>
<html>
  <body>
    <!-- 요소 노드의 콘텐츠 영역에 다른 요소 노드가 없고 텍스트만 존재 -> 
    <div id="foo">Hello</div>
  </body>
  <script>
    const $foo = document.getElementById('foo');
    // 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재한다면 
    // firstChild.nodeValueSt textcontent는 같은 결과를 반환한다. 
    console.log($foo.textcontent === $foo.firstChild.nodeValue); // true 
  </script>
</html>
```

- 요소 노드의 textcontent 프로퍼티에 문자열 할당 시 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가, HTML 마크업이 포함되어 있더라도 HTML 마크업 파싱 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // #foo 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 
    // 이때 HTML 마크업이 파싱되지 않는다.
    document.getElementById('foo').textcontent = 'Hi <span>there!</span>'; 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/92820c7e-786f-418e-b779-00665f7fec4d">
</div>

- 참고로 textcontent 프로퍼티와 유사한 동작을 히는 innerText 프로퍼티 존재,아래와 같은 이유로 사용 권장 X.

  - innerText 프로퍼티는 CSS에 순종적으로, innerText 프로퍼티는 CSS에 의해 비표시로 지정된 요소 노드의 텍스트를 반환 X.
 
  - innerText 프로퍼티는 CSS를 고려해야 하므로 textcontent 프로퍼티보다 느림.
<br>
