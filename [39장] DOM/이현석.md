# DOM

- DOM은 HTML 문서의 계층적 구조와 정보를 표현, 이를 제어할 수 있는 API로 프로퍼티와 메서드를 제공하는 트리 자료구조.
<br>

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

- **HTML 요소** : HTML 문서를 구성하는 개별적인 요소를 의미.

<div align="center">
  <img src="https://github.com/user-attachments/assets/0f4e1bc5-4ca0-4def-bb84-cc52299ea9c5">
</div>

-  HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환, 이때 요소의 어트리뷰트는 어트리뷰트 노드로, 요소의 텍스트 콘텐츠는 텍스트 노드로 변환.

<div align="center">
  <img src="https://github.com/user-attachments/assets/ca0fa8e1-4648-4767-8368-cb5cfc5fcd00">
</div>

- HTML 문서는 요소들의 집합으로 이루어져 중첩 관계를 가지는데, HTML 요소의 콘텐츠 영역에는 텍스트 뿐 아니라 다른 HTML 요소도 포함 가능.

- HTML 요소 간 중첩 관계에 의해 계층적인 부자관계가 형성되고 이러한 관계를 반영하여 HTML 문서의 구성 요소인 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료구조로 구성.

- **트리 자료구조**

  - 노드들의 계층 구조 즉, 부모 노드와 자식 노드로 구성되어 노드 간의 계층적 구조를 표현하는 비선형 자료구조를 지칭.
 
  - 하나의 최상위 노드(루트 노드)에서 시작 최상위는 부모 노드가 없으며, 0 ~ 2개 이상의 자식 노드(리프 노드)를 가짐.
 
  - 노드 객체들로 구성된 트리 자료구조가 DOM으로 노드 객체의 트리로 구조화되어 있기에 DOM 트리라 지칭.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/3123aeeb-008c-46b1-a181-69dad018664f">
  </div>
<br>

### 39.1.2 노드 객체의 타입

- 다음은 HTML 문서를 렌더링 엔진이 파싱하는 예시로.

```html
<!DOCTYPE html> 
<html>
  <head>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="style.css"> 
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li> 
      <li id="orange">0range</li> 
    </ul>
    <script src="app.js"x/script>
  </body>
</html>
```

- 렌더링 엔진은 위의 예시를 파싱하여 DOM을 생성.

<div align="center">
  <img src="https://github.com/user-attachments/assets/baa024c7-c836-4d43-bbd1-427efc44444b">
</div>

<div align="center">
  <img src="https://github.com/user-attachments/assets/38f1200e-68ca-49ef-a502-2af8479207b9">
</div>

- 노드 객체는 총 12 종류의 노드 타입이 있고, 그 중에서 중요한 노드 타입 4가지는 아래와 동일.

  - **문서 노드 document node**
 
    - DOM 트리의 최상위에 존재하는 루트 노드로 브라우저가 렌더링한 HTML 문서 전체를 가리키고 전역 객체 window의 document 프로퍼티에 바인딩 되어 존재.(window.document or document로 참조 가능)
   
    - 브라우저 환경의 모든 자바스크립트 코드는 script 태그에 의해 분리되어 있어도 하나의 전역 객체 window를 공유.(HTML 문서당 document 객체는 유일)
   
    - document 객체는 DOM 트리의 루트 노드로 다른 노드들에 접근을 위한 진입 역할로 요소, 어트리뷰트, 텍스트 노드에 접근 시 문서 노드를 통함.
   
  - **요소 노드 element node**
 
    - HTML 요소를 가리키는 객체로 요소 간의 중첩에 의해 부자 관계를 가지며, 부자 관계를 통해 정보를 구조화.(문서의 구조를 표현)
   
  - **어트리뷰트 노드 attribute node**  

    - HTML 요소의 어트리뷰트를 가리키는 객체로 어트리뷰트가 지정된 요소 노드와 연결, 부모 노드와 연결되어 있지 않고 요소 노드에만 연결.(요소 노드의 형제 노드 X)
   
    - 어트리뷰트 노드에 접근하여 어트리뷰트 참조 및 변경 시 요소 노드에 접근 필요.
   
  - **텍스트 노드 text node**
 
    - HTML 요소의 텍스트를 가리키는 객체로 문서 정보 표현, 요소 노드의 자식 노드이자 리프 노드로 DOM 트리의 최종단.
   
    - 텍스트 노드에 접근 시 부모 노드인 요소 노드에 접근 필요.
   
  - 외에도 주석을 위한 Comment 노드, DOCTYPE을 위한 DocumentType 노드, 복수의 노드를 생성하여 추가 시를 위한 DocumentFragment 노드 등 총 12개의 노드 타입 존재.
<br>

### 39.1.3 노드 객체의 상속 구조

- DOM은 HTML 문서의 계층적 구조와 정보를 표현하고, DOM을 구성하는 노드 객체는 자신의 구조와 정보를 제어할 수 있는 DOM API를 사용 가능.

- 노드 객체는 ECMAScript 사양에 정의된 표준 빌트인 객체가 아닌 브라우저 환경에서 추가적으로 제공하는 호스트 객체지만 노드 객체도 자바스크립트 객체로 프로토타입에 의한 상속 구조를 가짐.

<div align="center">
  <img src="https://github.com/user-attachments/assets/cd4d16d6-1341-40aa-b25b-adeea6b2beee">
</div>

- 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속받음.

  - 문서 노드는 Document, HTMLDocument 인터페이스를 상속.

  - 어트리뷰트 노드는 Attr를 상속.

  - 텍스트 노드는 CharacterData를 상속.
 
  - 요소 노드는 Element 인터페이스를 상속.(HTMLElement와 태그 종류별 HTMlHtmlElement, HTMLHeadElement, HTMLBodyElement, HTMLUListElement 상속)

- 프로토타입 체인 관점에서 input 요소 노드 객체는 프로토타입 체인에 있는 모든 프로토타입의 프로퍼티나 메서드를 상속받아 사용 가능.

<div align="center">
  <img src="https://github.com/user-attachments/assets/08257fc4-0c76-42e6-8231-ed879f9cc1f0">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <input type="text">
    <script>
      // input 요소 노드 객체를 선택 
      const $input = document.querySelector('input');

      // input 요소 노드 객체의 프로토타입 체인
      console.log(
        Object.getPrototypeOf($input) === HTMLInputElement.prototype,
        Object.getPrototypeOf(HTMLInputElement.prototype) === HTMLElement.prototype, 
        Object.getPrototypeOf(HTMLElement.prototype) === Element.prototype,
        Object.getPrototypeOf(Element.prototype) === Node.prototype, 
        Object.getPrototypeOf(Node.prototype) === EventTarget.prototype, 
        Object.getPrototypeOf(EventTarget.prototype) === Object.prototype 
      ); // 모두 true
    </script>
   </body>
</html>
```

- 배열이 객체인 동시에 배열인 것처럼 input 요소 노드 객체도 다양한 특성을 갖는 객체이며, 이러한 특성을 나타내는 기능들을 상속을 통해 제공.

<div align="center">
  <img src="https://github.com/user-attachments/assets/c5425f4f-7f85-4c83-bb48-1dbeae0dc457">
</div>

- 노드 객체의 상속 구조는 개발자 도구의 Elements 패널 우측의 Properties 패널에서 확인 가능.

<div align="center">
  <img src="https://github.com/user-attachments/assets/8c299981-f4af-4693-a96f-33a689a13d21">
</div>

- 노드 객체에는 노드 타입에 상관없이 모든 노드 객체가 공통으로 갖는 기능 및 노드 타입에 따른 고유한 기능도 존재.

  - **이벤트에 관련된 기능(EventTarget.addEventListener, EventTarget.removeEventListener 등)**
 
  - **트리 탐색 기능(Node.parentNode，Node.childNodes, Node.previousSibling, Node.nextSibling 등)**
 
  - **노드 정보 제공 기능(Node.nodeType, Node.nodeName 등)**

- 노드 객체는 공통된 기능일수록 프로토타입 체인의 상위에, 개별적인 고유 기능일수록 프로토타입 체인의 하위에 프로토타입 체인을 구축하여 노드 객체에 필요한 프로퍼티와 메서드를 제공하는 상속 구조.

- **DOM은 HTML 문서의 계층적 구조와 정보를 표현하는 것은 물론 노드 타입에 따과 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공.(HTML의 구조나 내용 or 스타일 등을 동적으로 조작 가능)**
<br>

## 39.2 요소 노드 취득

- HTML의 구조나 내용 또는 스타일 등을 등적으로 조작하려면 먼저 요소 노드를 취득 필요.

- 요소 노드의 취득은 HTML 요소를 조작하는 시작점으로 요소 노드를 취득할 수 있는 다양한 메서드를 제공.
<br>

### 39.2.1 id 를 이용한 요소 노드 취득

- Document.prototype.getElementByld 메서드는 인수로 전달한 id 어트리뷰트 값을 갖는 하나의 요소 노드를 탐색하여 반환.

- getElementByld 메서드는 Document.prototype의 프로퍼티로 반드시 문서 노드인 document를 통해 호출.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">0range</li>
    </ul>
    <script>
    // id 값이 'banana'인 요소 노드를 탐색하여 반환한다.
    // 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다. 
    const $elem = document.getElementById('banana');

    // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
    $elem.style.color = 'red';
    </script>
  </body>
</html> 
```

- id 값은 HTML 문서 내에서 유일한 값이지만 중복된 id 값을 갖는 HTML 요소가 여러 개 존재 시 에러 발생 X.

- id의 중복 존재 경우 getElementByld 메서드는 인수로 전달된 id 값을 갖는 첫 번째 요소 노드만 반환.

```html
<!DOCTYPE html>
<html>
  <body>
     <ul>
       <li id="banana">Apple</li>
       <li id="banana">Banana</li>
       <li id="banana">0range</li>
     </ul>
     <script>
      // getElementByld 메서드는 언제나 단 하나의 요소 노드를 반환한다.
      // 첫 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다. 
      const $elem = document.getElementById('banana');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      $elem.style.color = 'red';
     </script>
  </body>
</html> 
```

- 인수로 전달된 id 값을 갖는 HTML 요소가 존재하지 않는 경우 getElementByld 메서드는 nuU을 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">0range</li>
    </ul>
    <script>
      // id 값이 'grape'21 요소 노드를 탐색하여 반환한다. nullO/ 반환된다. 
      const $elem = document.getElementById('grape');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다.
      $elem.style.color = 'red';
      // — TypeError: Cannot read property 'style' of null 
    </script> 
  </body>
</html> 
```

- HTML 요소에 id 어트리뷰트를 부여하면 id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 부수 효과 존재.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo"></div>
    <script>
      // id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당된다.
      console.log(foo === document.getElementById('foo')); // true
      // 암묵적 전역으로 생성된 전역 프로퍼티는 삭제되지만 전역 변수는 삭제되지 않는다.
      delete foo;
      console.log(foo); // <div id="foo"></div>
    </script>
  </body>
</html> 
```

- 단，id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 이 전역 변수에 노드 객체 재할당 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo"></div>
    <script>
      let foo = 1;
      // id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 노드 객체가 재할당되지 않는다. 
      console.log(foo); // 1
    </script>
  </body>
</html> 
```
<br>

### 39.2.2 태그 이름을 이용한 요소 노드 취득

- Document. prototype/Element.prototype.getElementsByTagName 메서드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환.

- getElementsByTagName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
      // 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환된다.
      // HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
      const $etems = document.getElementsByTagName('li');
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다.
      // HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경한다. 
      [... $elems].forEach(elem => { elem.style.color = 'red'; }); 
    </script>
  </body>
</html> 
```

- getElementsByTagName 메서드가 반환하는 DOM 컬렉션 객체인 HTMLCollection 객체는 유사 배열 객체이면서 이터러블.

<div align="center">
  <img src="https://github.com/user-attachments/assets/9c36130b-f8a1-4c91-9c5c-c109781c273b">
</div>

- HTML 문서의 모든 요소 노드를 취득하려면 getElementsByTagName 메서드의 인수로 를 전달.

<div align="center">
  <img src="https://github.com/user-attachments/assets/02670867-9648-4b76-8fe9-11eb13dd2a84">
</div>

- getElementsByTagName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드 whswo.

  - Document.prototype.getElementsByTagName 메서드 : DOM의 루트 노드인 문서 노드를 통해 호출하며 DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype.getElementsByTagName 메서드 : 특정 요소 노드를 통해 호출하며, 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
      <1i>0range</1i>
    </ul>
    <ul>
      <U>HTML</1i>
    </ul>
    <script>
      // DOM 전체에서 태그 이름이 난인 요소 노드를 모두 탐색하여 반환한다.
      const $lisFromDocument = document.getElementsByTagName('li'); 
      console.log($lisFromDocument); // HTMLCollection(A) [li, li, li, li]
      // ulfffruits 요소의 자손 노드 중에서 태그 이름이 선인 요소 노드를 모두 탐색하여 반환한다.
      const $fruits = document.getElementById('fruits');
      const $lisFromFruits : $fruits.getElementsByTagName('li'); 
      console.log($lisFromFruits); // HTMLCollection(3) [li, li, li] 
    </script>
  </body>
</html> 
```

- 만약 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우 getElementsByTagName 메서드는 빈 HTMLCollection 객체를 반환.
<br>

### 39.2.3 class를 이용한 요소 노드 취득

- Document.prototype/Element.prototype.getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환.

- 인수로 전달할 class 값은 공백으로 구분하여 여러 개의 class를 지정 가능하고 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="fruit apple">App1e</_li>
      <li class="fruit banana">Banana</li>
      <li class="fruit orange">Orange</li>
    </ul>
    <script>
      // class 값이 'fruit'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다. 
      const $elems = document.getElementsByClassName('fruit');
      // 화득한 모든 요소의 CSS color 프로퍼티 값을 변경한다.
      [... $elems].forEach(elem => { elem.style.color = 'red'; });
      // class 값이 'fruit apple'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다. 
      const $apples = document.getElementsByClassName('fruit apple');
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      [... $apples].forEach(elem => { elem.style.color = 'blue'; }); 
    </script>
  </body>
</html> 
```

- getElementsByClassName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드 존재.

  - Document.prototype.getElementsByClassName 메서드 : DOM의 루트 노드인 문서 노드를 통해 호출하며 DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype.getElementsByClassName 메서드 : 특정 요소 노드를 통해 호출하며 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <div class="banana">Banana</div>
    <script>
      // DOM 전체에서 class 값01 'banana'인 요소 노드를 모두 탐색하여 반환한다. 
      const $bananasFromDocument = document.getElementsByClassName('banana'); 
      console.log($bananasFromDocument); 
      // HTMLCollection(2) [Ii.banana, div.banana]
      // ttfruits 요소의 자손 노드 중에서 class 값이 'banana'인 요소 노드를 모두 탐색하여 반환한다. 
      const $fruits = document.getElementById('fruits');
      const $bananasFromFruits = $fruits.getElementsByClassName('banana');
      console.log($bananasFromFruits); // HTMLCollection [li.banana] 
    </script>
  </body>
</html> 
```

- 인수로 전달된 class 값을 갖는 요소가 존재하지 않는 경우 getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환.
<br>

### 39.2.4 CSS 선택자를 이용한 요소 노드 취득

- CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법.

```css
/* 전체 선택자: 모든 요소를 선택 */
* { ... }
/* 태그 선택자: 모든 p 태그 요소를 모두 선택 */
P { ... }
/* id 선택자: id 값이 'foo'인 요소를 모두 선택 */
#foo { ... }
/* class 선택자: class 값이 'foo'인 요소를 모두 선택 */
.foo { ... }
/* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 'text'인 요소를 모두 선택 */ 
input[type=text] { ... }
/* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */ 
div p { ... }
/* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */
div > p { ... }
/* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */ 
p + ul { ... }
/* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */ 
p ~ ul { ... }
/* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */ 
a:hover { ... }
/* 가상 요소 선택자: p 요소의 콘텐츠의 앞에 위치하는 공간을 선택
  일반적으로 content 프로퍼티와 함께 사용된다. */ 
p:: before { ... }
```

- Document.prototype/Element.prototype.queryselector 메서드는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환.

  - 안수로 전달한 CSS 선택자를 만족시키는 요소 노드가 여러 개인 경우 첫 번째 요소 노드만 반환.
 
  - 안수로 전달된 CSS 선택자를 만족시키는 요소 노드가 존재하지 않는 경우 null을 반환.
 
  - 안수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // class 어트리뷰트 값이 'banana'인 첫 번째 요소 노드를 탐색하여 반환한다. 
      const $elem = document.querySelector('.banana');
      // 취득한 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      $elem.style.color = 'red';
    </script>
  </body>
</html> 
```

- querySelectorAll 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 NodeList 객체를 반환.(유사 배열 & 이터러블)

  - 안수로 전달된 CSS 선택자를 만족시키는 요소가 존재하지 않는 경우 빈 NodeList 객체를 반환.
 
  - 안수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // ul 요소의 자식 요소인 요소를 모두 탐색하여 반환한다.
      const $elems = document.querySelectorAll('ul > li');
      // 취득한 요소 노드들은 NodeList 객체에 담겨 반환된다. 
      console.log($elems); // NodeList(3) [li.apple, li.banana, li.orange]
      // 취득한 모든 요소 노드의 style, color 프로퍼티 값을 변경한다. 
      // IVodeList 는 for Each 메서드를 제공한다.
      $elems.forEach(elem => { elem.style.color = 'red'; }); 
    </script>
  </body>
</html> 
```
 
- HTML 문서의 모든요소노드를취득하려면 querySelectorAU 메서드의 인수로 전체 선택자 를 전달.

```js
// 모든 요소 노드를 탐색하여 반환한다.
const $all = document.querySelectorAll('*');
// — NodeList(8) [html, head, body, ul, liitapple, liltbanana, lifforange, script]
```

- queryselector, querySelectorAll 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드에 존재.

  - Document.prototype에 정의된 메서드는 DOM의 루트 노드인 문서 노드를 통해 호출하며, DOM 전체에서 요소 노드를 탐색하여 반환.

  - Element.prototype에 정의된 메서드는 특정 요소 노드를 통해 호출하며 특정 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환.
 
- CSS 선택자 문법을 사용하는 queryselector, querySelectorAll 메서드는 getElementByld, getElementsBy*** 메서드보다 다소 느린 것으로 알려져 있지만 구체적인 조건으로 요소 노드를 취득할 수 있고 일관된 방식으로 요소 노드를 취득할 수 있다는 장점 존재.

- 따라서, **id 어트리뷰트가 있는 요소 노드를 취득하는 경우에는 getElementByld 메서드를 사용하고 그 외의 경우에는 queryselector, querySelectorAll 메서드를 사용하는 것을 권장.**
<br>

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

- Element.prototype.matches 메서드는 인수로 전달한 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Appl.e</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    const $apple = document.querySelector('.apple');
    // $apple 노드는 '#fruits > li.apple’로 취득할 수 있다. 
    console.log($apple.matches('#fruits > li.apple')); // true
    // $apple 노드는 '#fruits > li.banana’로 취득할 수 없다. 
    console.log($apple.matches('fffruits > li.banana')); // false 
  </script>
</html> 
```

- Element.prototype.matches 메서드는 이벤트 위임을 사용할 때 유용.
<br>

### 39.2.6 HTMLCollection 과 NodeList

- DOM 컬렉션 객체인 HTMLCoUection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체로 유사 배열 객체 & 이터러블이여서 for... of 문으로 순회 및 스프레드 문법 사용 가능.

- 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 객체.

  - HTMLCollection은 언제나 live 객체로 동작.

  - NodeList는 대부분의 경우 노드 객체의 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작.(경우에 따라 live 객체로 동작)

- **HTMLCollection**

  -  getElementsByTagName, getElementsByClassName 메서드가 반환하는 HTMLCoUection 객체는 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 DOM 컬렉션 객체.(살아있는 객체)

  ```html
  <!DOCTYPE html>
  <head>
    <style>
      .red { color: red; }
      .blue { color: blue; }
    </style>
  </head>
  <html>
    <body>
      <ul id="fruits">
        <li class="red">Apple</li>
        <li class="red">Banana</li>
        <li class="red">Orange</li>
      </ul>
      <script>
        // class 값이 'red'인 요소 노드를 모두 탐색하여 HTMLCoUection 객체에 담아 반환한다. 
        const $elems = document.getElementsByClassName('red');
        // 이 시점에 HTMLCoUection 객체에는 3개의 요소 노드가 담겨 있다. 
        console.log($elems); // HTMLCollection(3) [li.red, li.red, li.red]
        // HTMLCollection 객체의 모든 요소의 class 값을 'blue'로 변경한다. 
        for (let i = 0; i < $elems.length; i++) { 
          $elems[i].className = 'blue'; 
        }
        // HTMLCollection 객체의 요소가 3개에서 1 개로 변경되었다. 
        console.log($elems); // HTMLCollection [li.red] 
      </script>
    </body>
  </html>
  ```
  
  - 위 예제가 에러 없이 실행되면 모든 li 요소의 class 값이 'blue'로 변경, 모든 li 요소는 CSS에 의해 파란색으로 렌더링 되어야 하지만 두 번째 li 요소만 class 값이 변경.
  
  <div align="center">
    <img src="https://github.com/user-attachments/assets/b6946030-ceca-4f2d-8d64-51f86ce8b163">
  </div>
  
  - 예상대로 동작하지 않은 이유를 알아보자면, $elems.length는 3으로 for 문의 코드 블록은 3번 반복.
  
  <div align="center">
    <img src="https://github.com/user-attachments/assets/fe95eb91-49bb-4a95-9b82-691760dd2e2d">
  </div>
  
  - HTMLCollection 객체는 실시간으로 노드 객체의 상태 변경을 반영하여 요소 제거가 가능하기에 for 문으로 순회하면서 노드 객체의 상태를 변경해야 할 때 주의 필요.
  
  - 위의 문제는 for 문을 역방향으로 순회하는 방법으로 회피 가능.
  
  ```js
  // for 문을 역방향으로 순회
  for (let i = $elems.length - 1; i >= 0; i--) { 
    $elems[i].className = 'blue';
  }
  ```
  
  - 또는 while 문을 사용하여 HTMLCollection 객체에 노드 객체가 남아 있지 않을 때까지 무한 반복하는 방법으로 회피 가능.
  
  ```js
  // while 문으로 HTMLCollection에 요소가 남아 있지 않을 때까지 무한 반복 
  let i = 0;
  while ($elems.length > i) {
    $elems[i].className = 'blue';
  }
  ```
  
  - 제일 간단한 해결책은 부작용을 발생시키는 원인인 유사 배열 객체이면서 이터러블인 HTMLCollection 객체를 배열로 변환 시 유용한 배열의 고차 함수 사용 가능.
  
  ```js
  // 유사 배열 객체이면서 이터러블인 HTMLCollection^ 배열로 변환하여 순회
  [ ... $elems].forEach(elem => elem.cIassName = 'blue');
  ```

- **NodeList**

  - HTMLCollection 객체의 부작용 해결로 querySelectorAll 메서드를 사용하는 것으로 DOM 컬렉션 객체인 NodeList 객체를 반환.(실시간으로 노드 객체의 상태 변경을 반영하지 않는 객체)

  ```js
  // querySelectorAll은 DOM 컬렉션 객체인 NodeList를 반환한다.
  const $elems = document.querySelectorAll('.red');
  
  // NodeList 객체는 NodeList. prototype. forEach 메서드를 상속받아 사용할 수 있다.
  $elems.forEach(elem => elem.className = 'blue');
  ```
   
  - querySelect이'All이 반환히는 NodeList 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용 가능.
  
  - NodeList 객체는 대부분 non-live 객체로 동작하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의가 필요.
  
  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
      <1i>Apple</1i>
      <1i>Banana</1i>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');
  
      // childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.
      const { childNodes } = $fruits; 
      console.log(childNodes instanceof NodeList); // true
  
      // $ fruits 요소의 자식 노드는 공백 렉스트 노드 (39.3.1 절 "공백 텍스트 노드" 참고)를 
      // 포함해 모두 5개다. 
      console.log(childNodes); // NodeList(5) [text, li, text, li, text]
  
      for (let i = 0; i < childNodes.length; i++) { 
        // removechild 메서드는 $ fruits 요소의 자식 노드를 DOM에서 삭제한다. 
        // (39.6.9절 "노드 삭제" 참고)
        // removechild 메서드가 을M 때마다 NodeList 객체인 childNodes가 실시간으로 
        // 따라서 첫 번째，세 번째, 다섯 번째 요소만 삭제된다. 
        $fruits.removeChild(childNodes[i]); 
      }
      // 예상과 다르게 $fruits 요소의 모든 자식 노드가 삭제되지 않는다. 
      console.log(childNodes); // NodeList(2) [li, li]
    </script>
  </html>
  ```
  
  - 노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장.
  
  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
      <1i>Apple</1i>
      <1i>Banana</1i>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');
  
      // childNodes 프로퍼티는 NodeList 객체(live)를 반환한다. 
      const { childNodes } = $fruits;
  
      // 스프러/드 문법을 사용하여 NodeList 객체를 배열로 변환한다. 
      [... childNodes].forEach(childNode => { 
        $fruits.removeChild(childNode); 
      })；
  
      // $ fruits 요소의 모든 자식 노드가 모두 삭제되었다. 
      console.log(childNodes); // NodeList [] 
    </script>
  </html>
  ```
<br>

## 39.3 노드 탐색

- 요소 노드 취득 후 DOM 트리의 노드를 옮겨 다니며 부모, 형제, 자식 노드등을 탐색 필요 시 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공.

<div align="center">
  <img src="https://github.com/user-attachments/assets/abd7a103-3c7d-4309-a348-222e9e664887">
</div>

- parentNode, previousSibling, firstChild, childNodes 프로퍼티는 Node.prototype이 제공, 프로퍼티키에 Element가 포함된 previousElementSibling, nextElementSibling과 children 프로퍼티는 Element.prototype이 제공.

- 노드 탐색 프로퍼티는 모두 접근자 프로퍼티지만 노드 탐색 프로퍼티는 setter없이 getter만 존재하여 참조만 가능한 읽기 전용 접근자 프로퍼티로 값 할당 시 에러 없이 무시.

<div align="center">
  <img src="https://github.com/user-attachments/assets/65eeca76-1603-472d-a21f-dc7bf06a08ab">
</div>
<br>

### 39.3.1 공백 텍스트 노드

- HTML 요소 사이의 스페이스, 탭, 줄바꿈 등의 공백 문자는 텍스트 노드를 생성.(공백 텍스트 노드)

```html
<!DOCTYPE htm1>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
</html>
```

- 텍스트 에디터에서 HTML 문서에 스페이스 키, 랩 키, 엔터 키 등을 입력하면 공백 문자가 추가되고 위 HTML 문서는 파싱되어 아래와 같은 DOM을 생성.

<div align="center">
  <img src="https://github.com/user-attachments/assets/c706ae3f-4574-45cc-8c5b-b0dead0a9f7c">
</div>

- 노드 탐색 시 공백 문자가 생성한 공백 텍스트 노드에 주의 필요, 아래와 같이 인위적으로 공백 문자 제거 시 공백 텍스트 노드를 생성하지 않지만 가독성이 좋지 않으므로 권장 X.

```html
<ul id="fruits"><li
 class="apple">App1e</1i><1i
 class=" banana">Banana</Li><Li
 class="orange">Orange</li></ul>
```
<br>

### 39.3.2 자식 노드 탐색

- 자식 노드를 탐색하기 위해서는 다음과 같은 노드 탐색 프로퍼티를 사용.

<div align="center">
  <img src="https://github.com/user-attachments/assets/e0888a58-14ab-4518-a31e-d0005f08a813">
  <img src="https://github.com/user-attachments/assets/a95dd0fd-354b-411b-bb8d-15ded18e9f65">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li> 
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 ^fruits 요소 노드를 취득한다. 
    const $fruits = document.getElementById('fruits');

    // #fruits 요소의 모든 자식 노드를 탐색한다.
    // childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있다. 
    console.log($fruits.childNodes);
    // NodeList(7) [text, li.apple, text, li.banana, text, li.orange, text]

    // fruits 요소의 모든 자식 노드를 탐색한다.
    // children 프로퍼티가 반환한 HTMLCollection에는 요소 노드만 포함되어 있다. 
    console.log($fruits.children);
    // HTMLCollection(3) [li.apple, li.banana, li.orange]

    // fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstChild 프로퍼티는 텍스트 노드를 반환할 수도 있다. 
    console.log($fruits.firstChild); // #text

    // fruits 요소의 마지막 자식 노드를 탐색한다.
    // lastchild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
    console.log($fruits.lastchild); // #text

    // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstElementChild 프로퍼티는 요소 노드만 반환한다. 
    console.log($fruits.firstElementchild); // li.apple

    // #fruits 요소의 마지막 자식 노드를 탐색한다.
    // lastElementChild 프로퍼티는 요소 노드만 반환한다. 
    console.log($fruits.lastElementchild); // li.orange 
  </script>
</html>
```
<br>

### 39.3.3 자식 노드 존재 확인

- 자식 노드가 존재하는지 확인하려면 Node.prototype.hasChildNodes 메서드를 사용, 자식 노드가 존재 유무에 따라 true/false 반환.(텍스트 노드를 포함하여 자식 노드의 존재를 확인)

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 //fruits 요소 노드를 취득한다.
    const $fruits = document.getElementById('fruits');
    // it fruits 요소에 자식 노드가 존재하는지 확인한다.
    // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 누드의 존재를 확인한다.
    console.log($fruits.hasChildNodes()); // true
  </script>
</html>
```

- 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인하려면 children.length or Element 인터페이스의 childElementCount 프로퍼티를 사용.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
    const $fruits = document.getElementById('fruits');

    // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 누드의 존재를 확인한다.
    console.log($fruits.hasChildNodes()); // true

    // 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인한다. 
    console.log(!!$fruits.children.length); // 0 — false 

    // 자식 노드 중에 렉스트 노드가 아닌 요소 노드가 존재하는자는 확인한다. 
    console.log(!!$fruits.childElementCount); // 0 — false 
  </script>
</html>
```
<br>

### 39.3.4 요소 노드의 텍스트 노드 탐색

- 요소 노드의 텍스트 노드는 요소 노드의 자식 노드로 firstChild 프로퍼티로 접근 가능하고 첫 번째 자식 노드를 반환, 반환한 노드는 텍스트 노드 or 요소 노드.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
    <script>
      // 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.
      console.log(document.getElementById('foo').firstChild); // #text
    </script>
  </body>
</html>
```
<br>

### 39.3.5 부모 노드 탐색

- 부모 노드를 탐색하려면 Node.prototype.parentNode 프로퍼티를 사용하고 텍스트 노드는 DOM 트리의 최종단 노드인 리프 노드로 부모 노드가 텍스트 노드인 경우 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 .banana 요소 노드를 취득한다.
    const $banana = document.querySelector('.banana');

    // .banana 요소 노드의 부모 노드를 탐색한다.
    console.log($banana.parentNode); // ul#fruits
  </script>
</html>
```
<br>

### 39.3.6 형제 노드 탐색

- 부모 노드가 같은 형제 노드 탐색 시 아래과 같은 노드 탐색 프로퍼티를 사용하지만 어트리뷰트 노드는 요소 노드와 연결되어 있지만 부모 노드가 같은 형제 노드가 아니기에 반환 X.(텍스트 노드 or 요소 노드만 반환)

<div align="center">
  <img src="https://github.com/user-attachments/assets/34bc8e1b-a7de-4019-907d-58c4eb9ba27f">
  <img src="https://github.com/user-attachments/assets/a6240764-d3cb-4bbd-a4a3-2aeb7e9562b7">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li> 
      <li class="banana">Banana</li> 
      <li class="orange">Orange</li> 
    </ul>
  </body>
  <script>
    // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다. 
    const $fruits = document.getElementById('fruits');
    
    // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
    // firstChild 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { firstChild } = $fruits; 
    console.log(firstChild); // ittext

    // #fruits 요소의 첫 번째 자식 노드(텍스트 노드)의 다음 형제 노드를 탐색한다. 
    // nextSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { nextSibling } = firstChild; 
    console.log(nextSibling); // li.apple

    // li.apple 요소의 이전 형제 노드를 탐색한다.
    // previousSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다. 
    const { previousSibling } = nextSibling;
    console.log(previousSibling); // #text

    // #fruits 요소의 첫 번째 자식 요소 노드를 탐색한다.
    // firstElementChild 프로퍼티는 요소 노드만 반환한다. 
    const { firstElementChild } = $fruits; 
    console.log(firstElementchild); // li.apple

    // #fruits 요소의 첫 번째 자식 요소 노드(li.apple)의 다음 형제 노드를 탐색한다. 
    // nextElementSibling 프로퍼티는 요소 노드만 반환한다.
    const { nextElementSibling } = firstElementchild; 
    console.log(nextElementSibling); // li.banana

    // li.banana 요소의 이전 형제 요소 노드를 탐색한다.
    // previousElementSibling 프로퍼티는 요소 노드만 반환한다. 
    const { previousElementSibling } = nextElementSibling; 
    console.log(previousElementSibling); // li.apple 
  </script>
</html>
```
<br>

## 39.4 노드 정보 취득

- 노드 객체에 대한 정보를 취득하려면 다음과 같은 노드 정보 프로퍼티를 사용.

<div align="center">
  <img src="https://github.com/user-attachments/assets/eb009cd9-d421-418c-ade5-14d1e8cb6773">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
  <script>
    // 문서 노드의 노드 정보를 취득한다.
    console.log(document.nodeType); // 9 
    console.log(document.nodeName); // itdocument

    // 요소 노드의 노드 정보를 취득한다.
    const $foo = document.getElementById('foo'); 
    console.log($foo.nodeType); // 1 
    console.log($foo.nodeName); // DIV

    // 텍스트 노드의 노드 정보를 취득한다.
    const $textNode = $foo.firstChild;
    console.log($textNode.nodeType); // 3 
    console. log($textNode.nodeName); // it text 
  </script>
</html>
```
<br>

## 39.5 요소 드의 텍스트 조작

### 39.5.1 nodeValue

- Node.prototype.nodeValue 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로 참조와 할당 모두 가능.

- 노드 객체의 nodeValue 프로퍼티 참조 시 노드 객체의 값을 반환, 텍스트 노드의 텍스트로 문서 노드나 요소 노드의 nodeValue 프로퍼티 참조 시 null을 반환.

```html
<!DOCTYPE htm1>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
  <script>
    // 문서 노드의 nodeValue 프로퍼티를 참조한다.
    console.log(document.nodeValue); // null

    // 요소 노드의 nodeValue 프로퍼티를 참조한다.
    const $foo = document.getElementById('foo');
    console.log($foo.nodeValue); // null

    // 텍스트 노드의 nodeValue 프로퍼티를 참조한다.
    const $textNode = $foo.firstChild;
    console.log($textNode.nodeValue); // Hello
  </script>
</html>
```

- 텍스트 노드의 nodevalue 프로퍼티에 값을 할당하면 텍스트 변경 가능함으로 요소 노드의 텍스트 변경 시 아래와 같은 순서가 필요.

  - 텍스트를 변경할 요소 노드 취득 후, 취득한 요소 노드의 텍스트 노드를 탐색, 요소 노드의 자식 노드이므로 firstChild 프로퍼티를 사용하여 탐색.
 
  - 탐색한 텍스트 노드의 nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경.

```html
<!DOCTYPE html>
<html> 
  <body>
    <div id="foo">He11o</div>
  </body>
  <script>
    // 1. ttfoo 요소 노드의 자식 노드인 텍스트 노드를 취득한다. 
    const $textNode = document.getElementById('foo').firstChild;

    // 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다. 
    $textNode.nodeValue = 'World';
    console.log($textNode.nodeValue); // World
  </script>
</html>
```
<br>

### 39.5.2 textcontent

- Node.prototype.textcontent 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득 or 변경.

- 요소 노드의 textcontent 프로퍼티 참조 시 요소 노드의 콘텐츠 영역 내의 텍스트를 모두 반환.(HTML 마크업은 무시)

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // fffoo 요소 노드의 텍스트를 모두 취득한다. 이때 HTML 마크업은 무시된다.
    console.log(document.getElementById('foo').textcontent); // Hello world! 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/33f2d6de-b27e-49a3-aaf2-3650f8977aab">
</div>

- nodevalue 프로퍼티 참조 시 텍스트 취득 가능하고 텍스트 노드의 nodeValue 프로퍼티를 참조 시만 텍스트 반환, 다만 textcontent 프로퍼티 사용 시 보다 복잡한 코드 생성.

```html
<!DOCTYPE htm1>
<html>
  <body> 
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // ttfoo 요소 노드는 텍스트 노드가 아니다.
    console.log(document.getElementById('foo').nodeValue); // null 

    // itfoo 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다. 
    console.log(document.getElementById('foo').firstChild.nodeValue); // Hello 

    // span 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다. 
    console.log(document.getElementById('foo').lastchild.firstChild.nodeValue); // world! 
  </script> 
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/d53b94e1-1a3e-4a57-82df-b83c2836fa55">
</div>

- 만약 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재 시 textcontent 프로퍼티를 사용하면 더 간단한 코드 생성.

```html
<!DOCTYPE html>
<html>
  <body>
    <!-- 요소 노드의 콘텐츠 영역에 다른 요소 노드가 없고 텍스트만 존재 -> 
    <div id="foo">Hello</div>
  </body>
  <script>
    const $foo = document.getElementById('foo');
    // 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재한다면 
    // firstChild.nodeValueSt textcontent는 같은 결과를 반환한다. 
    console.log($foo.textcontent === $foo.firstChild.nodeValue); // true 
  </script>
</html>
```

- 요소 노드의 textcontent 프로퍼티에 문자열 할당 시 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가, HTML 마크업이 포함되어 있더라도 HTML 마크업 파싱 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // #foo 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 
    // 이때 HTML 마크업이 파싱되지 않는다.
    document.getElementById('foo').textcontent = 'Hi <span>there!</span>'; 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/92820c7e-786f-418e-b779-00665f7fec4d">
</div>

- 참고로 textcontent 프로퍼티와 유사한 동작을 히는 innerText 프로퍼티 존재,아래와 같은 이유로 사용 권장 X.

  - innerText 프로퍼티는 CSS에 순종적으로, innerText 프로퍼티는 CSS에 의해 비표시로 지정된 요소 노드의 텍스트를 반환 X.
 
  - innerText 프로퍼티는 CSS를 고려해야 하므로 textcontent 프로퍼티보다 느림.
<br>

## 39.6 DOM 조작

- **DOM 조작**은 새로운 노드를 생성 후 DOM에 추가, 삭제 or 교체를 의미하며, 추가 & 삭제 시 리플로우와 리페인트 발생의 원인이 되므로 성능에 영향을 주기에 성능 최적화를 위해 주의가 필요.
<br>

### 39.6.1 innerHTML

- Element.prototype.innerHTML 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로 요소 노드의 HTML 마크업을 취득 or 변경.

- innerHTML 프로퍼티 참조 시 콘텐츠 영역 내에 포함된 모든 HTML 마크업을 문자열로 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // #foo 요소의 콘텐츠 영역 내의 HTML 마크업을 문자열로 취득한다. 
    console.log(document.getElementById('foo').innerHTML);
    // "Hello <span>world!</span>"
  </script>
</html>
```

- 앞의 textcontent 프로퍼티 참조 시 HTML 마크업을 무시하고 텍스트만 반환 but, innerHTML 프로퍼티는 HTML 마크업이 포함된 문자열을 그대로 반환.

<div align="center">
  <img src="https://github.com/user-attachments/assets/5e871d60-97d7-4d4c-a6b5-349dd476c35c">
</div>

- innerHTML 프로퍼티에 문자열 할당 시 모든 자식 노드가 제거되고 할당한 문자열에 포함된 HTML 마크업이 파싱되어 요소 노드의 자식 노드로 DOM에 반영.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // HTML 마크업이 파싱되어 요소 노드의 자식 노드로 DOM에 반영된다.
    document.getElementById('foo').innerHTML = 'Hi <span>there!</span>'; 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/24078485-5174-4ea5-a088-bb4ea1cccbae">
</div>

- 그림처럼 innerHTML 프로퍼티 사용 시 HTML 마크업 문자열로 간단히 DOM 조작 가능.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 노드 추가
    $fruits.innerHTML += '<li class="banana">Banana</li>';

    // 노드 교체
    $fruits.innerHTML = '<li class="orange">Orange</li>';

    // 노드 식제
    $fruits.innerHTML = '';
  </script>
</html>
```

- innerHTML 프로퍼티에 할당한 HTML 마크업 문자열은 렌더링 엔진에 의해 파싱되어 요소 노드의 자식으로 DOM에 반영.

- 이때 사용자로부터 입력받은 데이터를 그대로 innerHTML 프로 퍼티에 할당하는 것은 **크로스 사이트 스크립팅 공격**에 취약.

- HTML 마크업 내에 자바스크립트 악성 코드가 포함되어 있다면 파싱 과정에서 그대로 실행될 가능성이 있기 때문.

- 아래의 코드는 innerHTML 프로퍼티로 스크립트 태그를 삽입하여 자바스크립트가 실행되도록 하는 예제.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id«"foo">Hello</div>
  </body>
  <script>
    // innerHTML 프로퍼티로 스크립트 대그률 상입하여 자바스크랍트가 실행되도록 한다.
    // HTML5는 innerHTML 프로퍼타로 삽입된 script 요소 내의 자바스크랍트 코드료 실행하지 않는다.
    document.getElementById('foo').innerHTML = '<script>alert(document.cookie)</script>';
  </script>
</html>
```

- HTML5는 innerHTML 프로퍼티로 삽입된 script 요소 내의 자바스크립트 코드를 실행하지 않기에 위 예제는 동작하지 않지만 script 요소 없이도 크로스 사이트 스크립팅 공격은 가능.

- 아래의 코드는 크로스 사이트 스크립팅 공격은 모던 브라우저에서도 동작하는 예제.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id«"foo >Hello</div>
  </body>
  <script>
    // 에러 이벤트를 강제로 발생시켜서 자바스크립트 코드가 실행되도록 한다. 
    document.getElementById('foo').innerHTML = `<img src="x" onerror="alert(document.cookie)">`; 
  </script>
</html>
```

- 이처럼 innerHTML 프로퍼티를 사용한 DOM 조작은 구현이 간단하고 직관적이라는 장점이 있지만 크로스 사이트 스크립팅 공격에 취약.

<div align="center">
  <img src="https://github.com/user-attachments/assets/4af20f93-bbb2-4b3f-b8ab-7e1c34ff4d6f">
</div>

- innerHTML 프로퍼티의 또 다른 단점은 innerHTML 프로퍼티에 HTML 마크업 문자열 할당 시 요소 노드의 모든 자식 노드를 제거하고 할당한 HTML 마크업 문자열을 파싱하여 DOM을 변경.

```html
<!DOCTYPE html>
<html>
    <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 노드 추가
    $fruits.innerHTML += '<li class="banana">Banana</li>';
  </script>
</html>
```

- innerHTML 프로퍼티에 HTML 마크업 문자열 할당 시 유지되어도 좋은 기존의 자식 노드까지 모두 제거하고 다시 새롭게 자식 노드를 생성 후 DOM에 반영.(비 효율적)

- innerHTML 프로퍼티는 새로운 요소를 삽입할 때 삽입될 위치를 지정할 수 없다는 단점도 존재.

```html
<ul id="fruits">
  <li class="apple">Apple</li>
  <li class="orange">Orange</li>
</ul> 
```

- li.apple 요소와 li.orange 요소 사이에 새로운 요소를 삽입하고 싶은 경우 innerHTML 프로퍼티 사용 시 삽입 위치를 지정 불가능.

- 따라서 innerHTML 프로퍼티는 복잡하지 않은 요소의 새로운 추가 시 유용하지만 기존 요소 제거 없이 위치 지정을 통해 요소 삽입의 경우 사용 비 추천.
<br>

### 39.6.2 insertAdjacentHTML 메서드

- Element.prototype.insertAdjacentHTML(position, DOMString)메서드는 기존 요소 제거 없이 위치 지정을 통해 새로운 요소를 삽입.

- 두 번째 인수로 전달한 HTML 마크업 문자열을 파싱하고 그 결과로 생성된 노드를 첫 번째 인수로 전달한 위치에 삽입하여 DOM에 반영.

- 첫 번째 인수로 전달 가능한 문자열은 'beforebegin', 'afterbegin', 'beforeend', 'afterend'의 4가지.

<div align="center">
  <img src="https://github.com/user-attachments/assets/6a603653-557c-45a1-ad4f-8d95e3ffd9e3">
</div>

```html
<!DOCTYPE html>
<html>
  <body>
    <!— beforebegin —>
    <div id="foo">
      <!-- afterbegin -->
      text
      <!-- beforeend -->
    </div>
    <!— afterend -->
  </body>
  <script>
    const $foo = document.getElementById('foo1);

    $foo.insertAdjacentHTML('beforebegin', '<p>beforebegin</p>');
    $foo.insertAdjacentHTML('afterbegin', '<p>afterbegin</p>'); 
    $foo.insertAdjacentHTML('beforeend', '<p>beforeend</p>'); 
    $foo.insertAdjacentHTML('afterend', '<p>afterend</p>'); 
  </script>
</html>
```

- insertAdjacentHTML 메서드는 기존 요소에 영향 없이 삽입될 요소만을 파싱하여 자식 요소로 추가하므로 innerHTML 프로퍼티보다 효율적.

- 단, innerHTML 프로퍼티와 마찬가지로 HTML 마크업 문자열을 파싱하므로 크로스 사이트 스크립팅 공격에 취약하다는 점은 동일.
<br>

### 39.6.3 노드 생성과 추가

- DOM은 노드를 직접 생성/삽입/삭제/치환하는 메서드도 제공.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>App1e</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 1. 요소 노드 생성
    const $li = document.createElement('li');

    // 2. 텍스트 노드 생성
    const textNode = document.createTextNode('Banana');

    // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
    $li.appendChitd(textNode);

    // 4. $li 요소 노드를 fruits 요소 노드의 마지막 자식 노드로 추가 
    $fruits.appendChild($li);
  </script>
</html>
```

- **요소 노드 생성**

  - Document.prototype.createElement(tagName) 메서드는 요소 노드를 생성하여 반환, 태그 이름을 나타내는 문자열을 인수로 전달.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/1736b23b-7478-40bb-b921-d11b75a9a77b">
  </div>

  - createElement 메서드는 요소 노드를 생성할 뿐 DOM에 추가하지는 않기에 이후 생성된 요소 노드를 DOM에 추가하는 처리가 별도로 필요.

  - 생성한 요소 노드는 아무런 자식 노드를 가지고 있지 않기에 요소 노드의 자식 노드인 텍스트 노드도 없는 상태.

- **텍스트 노드 생성**

  - Document.prototype.createTextNode(text) 메서드는 텍스트 노드를 생성하여 반환, 텍스트 노드의 값으로 사용할 문자열을 인수로 전달.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/8b5866f6-c9b8-4ef0-afe9-fe042e0d6ac2">
  </div>

  - createElement 메서드와 마찬가지로 텍스트 노드를 생성할 뿐 요소 노드에 추가하지는 않기에 이후 생성된 텍스트 노드를 요소 노드에 추가하는 처리가 별도로 필요.

- **텍스트 노드를 요소 노드의 자식 노드로 추가**

  - Node.prototype.appendChild(childNode) 메서드는 매개변수 childNode에게 인수로 전달한 노드를 appendChild 메서드를 호출한 노드의 마지막 자식 노드로 추가.
 
  - appendChild 메서드의 인수로 createTextNode 메서드로 생성한 텍스트 노드 전달 시 appendChild 메서드를 호출한 노드의 마지막 자식 노드로 텍스트 노드가 추가.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/88771443-0c6e-45fe-a970-7a320dfea590">
  </div>

  - 요소 노드에 자식 노드가 하나도 없는 경우 textcontent 프로퍼티를 사용하는 편이 더욱 간편.

  ```html
  // 텍스트 노드를 생성하여 요소 노드의 자식 노드로 추가 
  $li.appendChild(document.createTextNode('Banana'));
  
  // 요소 노드에 자식 노드가 하나도 없는 위 코드와 동일하게 동작한다. 
  $li.textcontent = 'Banana';
  ```

  - 단, 요소 노드에 자식 노드가 있는 경우 요소 노드의 textcontent 프로퍼티에 문자열 할당 시 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가되므로 주의 필요.

- **요소 노드를 DOM에 추가**

  - Node.prototype.appendChild 메서드를 사용하여 텍스트 노드와 부자 관계로 연결한 요소 노드를 #fruits 요소 노드의 마지막 자식 요소로 추가.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/fdca5033-7e94-4466-b993-7309a2391857">
  </div>
 
  - 단 하나의 요소 노드를 생성하여 DOM에 한번 추가하므로 DOM은 한 번 변경.(이때 리플로우와 리페인트가 실행)
<br>

### 39.6.4 복수의 노드 생성과 추가

- 이번에는 여러 개의 요소 노드를 생성하여 DOM에 추가.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits"></u'l>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    ['Apple', 'Banana', 'Orange'].forEach(text => { 
      // 1. 요소 노드 생성
      const $li = document.createElement('li');

      // 2. 텍스트 노드 생성 
      const textNode = document.createTextNode(text);

      // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가 
      $li.appendChild(textNode);

      // 4. $li 요소 노드를 /ffruits 요소 노드의 마지막 자식 노드로 추가 
      $fruits.appendChild($li);
    });
  </script>
</html>
```

- 먼저 DocumentFragment 노드를 생성하고 DOM에 추가할 요소 노드를 생성하여 Document Fragment 노드에 자식 노드로 추가한 다음, DocumentFragment 노드를 기존 DOM에 추가.

- 이때 실제로 DOM 변경과 리플로우와 리페인트가 한 번만 실행되기에 여러 개의 요소 노드를 DOM에 추가하는 경우 DocumentFragment 노드를 사용하는 것이 더 효율적.
<br>

### 39.6.5 노드 삽입

- **마지막 노드로 추가**

  - Node.prototype.appendChild 메서드는 인수로 전달받은 노드를 자신을 호출한 노드의 마지막 자식 노드로 DOM에 추가, 이때 추가할 위치 지정이 불가능.(마지막 자식 노드로 추가)

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits"> 
        <li>Apple</li>
        <li>Banana</li>
      </ul>
    </body>
    <script>
      // 요소 노드 생성
      const $li = document.createElement('li');
  
      // 텍스트 노드를 $li 요소 누도의 마지막 자식 노드로 추가
      $li.appendChild(document.createTextNode('Orange'));
  
      // $li 요소 노드를 itfruits 요소 노드의 마지막 자식 노드로 추가 
      document.getElementByld('fruits').appendChild($li); 
    </script>
  </html>
  ```

  <div align="center">
    <img src="https://github.com/user-attachments/assets/25a6d69c-c1fa-4591-bffe-0b10205e8dad">
  </div>

- **지정한 위치에 노드 삽입**

  - Node.prototype.insertBefore(newNode, childNode) 메서드는 첫 번째 인수로 전달받은 노드를 두 번째 인수로 전달받은 노드 앞에 삽입.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li>App1e</li>
        <li>Banana</li>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');

      // 요소 노드 생성
      const $li = document.createElement('li');

      // 텍스트 노드를 $li 요소 노드의 마지막 자식 뉴[로 추가
      $li.appendChild(document.createTextNode('Orange'));

      // 와i 요소 노드를 fruits 요소 노드의 마지막 자식 요소 앞에 삽입 
      $fruits.insertBefore($li, $fruits.lastElementChild); // Apple - Orange - Banana 
    </script>
  </html>
  ```

  <div align="center">
    <img src="https://github.com/user-attachments/assets/37738918-d65c-41f7-8fcb-1233c31e9c61">
  </div>

  - 두 번째 인수로 전달받은 노드는 반드시 insertBefore 메서드를 호출한 노드의 자식 노드이어야 하고 그렇지 않으면 DOMException 에러가 발생.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <div>test</div>
      <ul id="fruits">
        <li>Apple</li>
        <li>Banana</li>
      </ul>
    </body>
    <script>
      const $fruits = document.getEl_ementById(' fruits' );

      // 요소 노드 생성
      const $li = document.createElement('li');

      // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가 
      $li.appendChild(document.createTextNode('Orange'));

      // 두 번째 인수로 전달받은 노드는 반드시 #fruits 요소 노드의 자식 노드이어야 한다. 
      $fruits.insertBefore($li, document.querySelector('div')); // DOMException 
    </script>
  </html>
  ```

  - 두 번째 인수로 전달받은 노드가 null이면 첫 번째 인수로 전달받은 노드를 insertBefore 메서드를 호출한 노드의 마지막 자식 노드로 추가.(appendChild 메서드처럼 동작)

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <1i>Appl_e</1i>
        <1i>Banana</1i>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');

      // 요소 노드 생성
      const $li = document.createElement('li');

      // 텍스트 노드를 요소 노드의 마지막 자식 노드로 추가
      $li.appendChild(document.createTextNode('Orange1));

      // 두 번째 인수로 전달받은 노드가 null이면 $li 요소 노드를 ttfruits 요소 노드의 
      // 마지막 자식 노드로 추가
      $fruits.insertBefore($li, null);
    </script>
  </html>
  ```

  <div align="center">
    <img src="https://github.com/user-attachments/assets/1b423604-59a9-49a3-8fda-f7ca842f6953">
  </div>
<br>

### 39.6.6 노드 이동

- DOM에 이미 존재하는 노드를 appendChild or insertBefore 메서드를 사용하여 DOM에 다시 추가하면 현재 위치에서 노드를 제거하고 새로운 위치에 노드를 추가.(노드 이동)

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 이미 존재하는 요소 노드를 취득
    const [$apple, $banana, ] = $fruits.children;

    // 이미 존재하는 $apple 요소 노드를 fffruits 요소 노드의 마지막 노드로 이동 
    $fruits.appendChild($apple); // Banana 

    // 이미 존재하는 $banana 요소 노드를
    $fruits.insertBefore($banana, $fruits.lastElementchild); // Orange - Banana - Apple
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/82aa8666-f0a5-4bb8-80f4-f9321022531d">
</div>
<br>

### 39.6.7 노드 복사

- Node.prototype.cloneNode([deep: true | false]) 메서드는 노드의 사본을 생성하여 반환.

  - true를 인수로 전달하면 노드를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성.

  - false를 인수로 전달하거나 생략하면 노드를 얕은 복사하여 노드 자신만의 사본을 생성.
 
  - 얕은 복사로 생성된 요소 노드는 자손 노드를 복사하지 않으므로 텍스트 노드도 X.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');
    const $apple = $fruits.firstElementchild;

    // $apple 요소를 얕은 복사하여 사본을 생성. 텍스트 노드가 없는 사본이 생성된다.
    const $shallowClone = $apple.cloneNode();

    // 사본 요소 노드에 텍스트 추가
    $shaIlowClone.textcontent = 'Banana';

    // 사본 요소 노드를 fruits 요소 노드의 마지막 노드로 추가
    $fruits.appendChild($shallowClone);

    // #fruits 요소를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성
    const $deepClone = $fruits.cloneNode(true);

    // 사본 요소 노드를 fruits 요소 노드의 마지막 노드로 추가
    $fruits.appendChild($deepClone);
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/4c5c76f3-c8aa-4c75-b521-76cf63ef5d7f">
</div>
<br>

### 39.6.8 노드 교체

- Node.prototype.replaceChild(newChild, oldChild) 메서드는 자신을 호출한 노드의 자식 노드를 다른 노드로 교체.

- 첫 번째 매개변수 newChild에는 교체할 새로운 노드를 인수로 전달, 두 번째 매개변수 oldChild에는 이미 존재하는 교체될 노드를 인수로 전달.

- oldChild 노드를 newChild 노드로 교체,  oldChild 노드는 DOM에서 제거.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 가존 노드와 교체할 요소 노드를 생성 
    const $newChitd = document.createElement('li'); 
    $newChild.textcontent = 'Banana';

    // #fruits 요소 노드의 첫 번째 자식 요소 노드를 $newChild 요소 노드로 교체 
    $fruits.replaceChild($newChild, $fruits.firstElementchild); 
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/84e19a0c-b902-4ce6-9904-6df2baef2c4b">
</div>
<br>

### 39.6.9 노드 삭제

- Node.prototype.removeChild(child) 메서드는 child 매개변수에 인수로 전달한 노드를 DOM에서 삭제.(인수는 removechild 메서드를 호출한 노드의 자식 노드)

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // #fruits 요소 노드의 마지막 요소를 DOM에서 삭제
    $fruits.removeChild($fruits.lastElementchild);
  </script>
</html>
```

<div align="center">
  <img src="https://github.com/user-attachments/assets/f03f3fb6-a7f0-4dc5-b8e9-f7dc3cbee0bf">
</div>
<br>

## 39.7 어트리뷰트

### 39.7.1 어트리뷰트 노드와 attributes 프로퍼티

- HTML 문서의 구성 요소인 HTML 요소는 여러 개의 어트리뷰트를 가질 수 있고 HTML 요소의 동작을 제어하기 위한 추가적인 정보를 제공하는 HTML 어트리뷰트는 HTML 요소의 시작 태그에 `어트리뷰트 이름 = "어트리뷰트 값"` 형식으로 정의.

- 글로벌 어트리뷰트와 이벤트 핸들러 어트리뷰트는 모든 HTML 요소에서 공통적으로 사용할 수 있지만 특정 HTML 요소에만 한정적으로 사용 가능한 어트리뷰트도 존재.

- HTML 문서가 파싱될 때 HTML 요소의 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결되어 이때 HTML 어트리뷰트당 하나의 어트리뷰트 노드가 생성.

- 모든 어트리뷰트 노드의 참조는 유사 배열 객체이자 이터러블인 NamedNodeMap 객체에 담겨서 요소 노드의 attributes 프로퍼티에 저장.

<div align="center">
  <img src="https://github.com/user-attachments/assets/b2675d90-c2f7-4f1d-9d1e-1e3cf2bcc880">
</div>

- attributes 프로퍼티는 getter만 존재하는 읽기 전용 접근자 프로퍼티이며, 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴 NamedNodeMap 객체를 반환.

```html
<!DOCTYPE html>
<html>
  <body>
    <input id="user" type="text" value="ungmo2">
    <script>
      // 요소 노드의 attribute 프로퍼티는 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴
      // NamedNodeMap 객체를 반환한다.
      const { attributes } = document.getElementById('user'); 
      console.log(attributes);
  
      // NamedNodeMap {0： id, 1： type, 2： value, id: id, type: type, value: value, length: 3}
      // 어트리뷰트 값 취득
      console.log(attributes.id.value); // user
      console.log(attributes.type.value); // text
      console.log(attributes.value.value); // ungmo2
    </script>
  </body>
</html>
```
<br>

### 39.7.2 HTML 어트리뷰트 조작

- Element.prototype.getAttribute/setAttribute 메서드를 사용하면 attributes 프로퍼티를 통하지 않고 요소 노드에서 메서드를 통해 직접 HTML 어트리뷰트 값을 취득하거나 변경 가능.

  - HTML 어트리뷰트 값을 참조 시 Element.prototype.getAttribute(attributeName) 메서드를 사용.

  - HTML 어트리뷰트 값을 변경 사 Element.prototype.setAttribute(attributeName, attributevalue) 메서드를 사용.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        const $input = document.getElementById('user');
  
        // value 어트리뷰트 값을 취득
        const inputvalue = $input.getAttribute('value');
        console.log(inputvalue); // ungmo2
  
        // value 어트리뷰트 값을 변경
        $input.setAttribute('value'， 'foo');
        console.log($input.getAttribute('value')); // foo
      </script>
    </body>
  </html>
  ```

  - 특정 HTML 어트리뷰트가 존재하는지 확인 시 Element.prototype.hasAttribute(attributeName) 메서드를 사용.
  
  - 특정 HTML 어트리뷰트를 삭제 시 Element.prototype.removeAttribute(attributeName) 메서드를 사용.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        const $input = document.getElementById('user1);
        // value 어트리뷰트의 존재 확인
  
        if ($input.hasAttribute('value')) { 
  
          // value 어트리뷰트 삭제 
          $input.removeAttribute('value'); 
        }
  
        // value 어트리뷰트가 삭제되었다.
        console.log($input.hasAttribute('value')); // false 
      </script>
    </body>
  </html>
  ```
<br>

### 39.7.3 HTML 어트리뷰트 vs DOM 프로퍼티

- 요소 노드 객체에는 HTML 어트리뷰트에 대응하는 프로퍼티가 존재, 이 DOM 프로퍼티들은 HTML 어트리뷰트 값이 초기값.

<div align="center">
  <img src="https://github.com/user-attachments/assets/c72879ca-84ae-4d4a-a2ef-b3bf86608f91">
</div>

- DOM 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티여서 DOM 프로퍼티는 참조와 변경이 가능.

```html
<!DOCTYPE html>
<html>
  <body>
    <input id="user" type="text" value="ungmo2">
    <script>
      const $input = document.getElementById('user');

      // 요소 노드의 value 프로퍼티 값을 변경
      $input.value = 'foo';

      // 요소 노드의 value 프로퍼티 값을 참조
      console.log($input.value); // foo
    </script>
  </body>
</html>
```

- 이처럼 HTML 어트리뷰트는 다음과 같이 DOM에서 중복 관리되고 있는 것처럼 보임.

  - 요소 노드의 attributes 프로퍼티에서 관리하는 어트리뷰트 노드.
 
  - HTML 어트리뷰트에 대응하는 요소 노드의 프로퍼티(DOM 프로퍼티).

- HTML 어트리뷰트의 역할을 살펴 보자면 **HTML 어트리뷰트의 역할은 HTML 요소의 초기 상태를 지정하는 것으로 HTML 어트리뷰트 값은 HTML 요소의 초기 상태를 의미.**

```html
<!DOCTYPE html>
<html>
  <body>
    <input id="user" type="text" value="ungmo2">
    <script>
      const $input = document.getElementById('user');

      // attributes 프로퍼티에 저장된 value 어트리뷰트 값 
      console.log($input.getAttribute('value')); // ungmo2

      // 요소 노드의 value 프로퍼티에 저장된 value 어트리뷰트 값 
      console.log($input.value); // ungmo2
    </script>
  </body>
</html>
```

-  input 요소의 요소 노드가 생성되어 첫 렌더링이 끝난 시점까지 어트리뷰트 노드의 어트리뷰트 값과 요소 노드의 value 프로퍼티에 할당된 값은 HTML 어트리뷰트 값과 동일 하지만 첫 렌더 링 이후 사용자가 input 요소에 무언가를 입력하기 시작하면 상황이 달라짐.

- **요소 노드는 초기 상태와 최신 상태를 관리, 요소 노드의 초기 상태는 어트리뷰트 노드가 관리하며, 요소 노드의 최신 상태는 DOM 프로퍼티가 관리.**

- **어트리뷰트 노드**

  - 어트리뷰트 노드에서 관리하는 어트리뷰트 값은 사용자의 입력에 의해 상태가 변경되어도 변하지 않고 HTML 어트리뷰트로 지정한 HTML 요소의 초기 상태를 그대로 유지.
 
  - 어트리뷰트 노드가 관리하는 초기 상태 값을을 취득하거나 변경하려면 getAttribute/setAttribute 메서드를 사용.
 
    - getAttribute 메서드로 취득한 값은 어트리뷰트 노드에서 관리하는 HTML 요소에 지정한 어트리뷰트 값.(초기 상태 값)
   
    - setAttribute 메서드는 어트리뷰트 노드에서 관리하는 HTML 요소에 지정한 어트리뷰트 값.(초기 상태값을 변경)

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        // HTML 요소에 지정한 어트리뷰트 값，즉 초기 상태 값을 변경한다.
        document.getElementById('user').setAttribute('value', 'foo'); 
      </script>
    </body>
  </html>
  ```

  <div align="center">
    <img src="https://github.com/user-attachments/assets/d24af556-483f-442e-9ee8-d8a0786865bc">
  </div>

- **DOM 프로퍼티**

  - DOM 프로퍼티로 취득한 값은 HTML 요소의 최신 상태 값을 의미, 사용자의 입력에 의해 언제든지 동적으로 변경되어 최신 상태를 유지.(초기 상태 값은 변하지 않고 유지)

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        const $input = document.getElementById('user');

        // 사용자가 input 요소의 입력 필드에 값을 입력할 때마다 input 요소 +〔의 value 프로퍼티 값， 
        // 즉 최신 상태 값을 취득한다. value 프로퍼타 값은 사용자의 입력에 의해 동적으로 변경된다. 
        $input.oninput =()=>{
          console.log( 'value 프로퍼티 값'， $input.value);
        };
        
        // getAttribute 메서드로 취득한 HTML 어트리뷰트 값, 즉 초기 상태 값은 변하지 않고 유지된다. 
        console.log( 'value 어트리뷰트 값’，$input.getAttribute( 'value')); 
      </script>
    </body>
  </html>
  ```

  - DOM 프로퍼티에 값을 할당하는 것은 HTML 요소의 최신 상태 값을 변경하는 것을 의미.(사용자가 상태를 변경하는 행위)

  - 이때 HTML 요소에 지정한 어트리뷰트 값에 영향 X.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        const $input = document.getElementById('user');

        // DOM 프로퍼티에 값을 할당하여 HTML 요소의 최신 상태를 변경한다.
        $input.value = 'foo';
        console.log($input.value); // foo

        // getAttribute 메서드로 취득한 HTML 어트리뷰트 값, 즉 초기 상태 값은 변하지 않고 유지된다. 
        console.log($input.getAttribute('value')); // ungmo2
      </script>
    </body>
  </html>
  ```

  - HTML 요소의 초기 상태 값을 관리하고 DOM 프로퍼티는 사용자의 입력에 의해 변경되는 최신 상태를 관리.

  - 단, 모든 DOM 프로퍼티가 사용자의 입력에 의해 변경되 최신 상태를 관리하는 것은 아니기에 사용자 입력에 의한 상태 변화와 관계없는 id 어트리뷰트와 id 프로퍼티는 사용자 입력과 관계없이 항상 동일한 값을 유지.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input id="user" type="text" value="ungmo2">
      <script>
        const $input = document.getElementById('user');

        // id 어트리뷰트와 id 프로퍼티는 사용자 입력과 관계없이 항상 동일한 값으로 연동한다. 
        $input.id = 'foo';
        console.log($input.id); // foo
        console.log($input.getAttribute('id')); // foo
      </script>
    </body>
  </html>
  ```

  - 사용자 입력에 의한 상태 변화와 관계있는 DOM 프로퍼티만 최신 상태 값을 관리, 그 외의 사용자 입력에 의한 상태 변화와 관계없는 어트리뷰트와 DOM 프로퍼티는 항상 동일한 값으로 연동.

- **HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계**

  - 대부분의 HTML 어트리뷰트는 HTML 어트리뷰트 이름과 동일한 DOM 프로퍼티와 1:1로 대응.
 
  - 항상은 아니기에 아래는 예외의 상황.
 
    - id 어트리뷰트와 id 프로퍼티는 1:1 대응하며, 동일한 값으로 연동.
   
    - input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 대응하지만 value 어트리뷰트는 초기 상태, value 프로퍼티는 최신 상태.
   
    - class 어트리뷰트는 className, classList 프로퍼티와 대응.
   
    - for 어트리뷰트는 htmlFor 프로퍼티와 1:1 대응.
   
    - td 요소의 colspan 어트리뷰트는 대응하는 프로퍼티가 존재 X.
   
    - textcontent 프로퍼티는 대응하는 어트리뷰트가 존재 X.
   
    - 어트리뷰트 이름은 대소문자를 구별하지 않지만 대응하는 프로퍼티 카는 카멜 케이스.(maxl_ength —> maxLength)

- **DOM 프로퍼티 값의 타입**

  - getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이지만 DOM 프로퍼티로 취득한 최신 상태 값은 문자열이 아닐 가능성 존재.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <input type="checkbox" checked>
      <script>
        const $checkbox = document.querySelector('input[type=checkbox]');

        // getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이다. 
        console.log($checkbox.getAttribute('checked')); // ''

        // DOM 프로퍼티로 화득한 최신 상태 값은 문자열이 아닐 수도 있다. 
        console.log($checkbox.checked); // true
      </script>
    </body>
  </html>
  ```
<br>

### 39.7.4 data 어트리뷰트와 dataset 프로퍼티

- data 어트리뷰트와 dataset 프로퍼티를 사용하면 HTML 요소에 정의한 사용자 정의 어트리뷰트와 자바스크립트 간에 데이터 교환 가능.

- data 어트리뷰트는 data-user-id, data-role과 같이 data- 접두사 다음에 임의의 이름을 붙여 사용.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul class="users">
      <li id="l" data-user-id="7621" data-role="admin">Lee</li>
      <li id="2" data-user-id="9524" data-role="subscriber">Kim</li>
    </ul>
  </body>
</html>
```

- data 어트리뷰트의 값은 HTMLElement.dataset 프로퍼티로 취득 가능, dataset 프로퍼티는 HTML 요소의 모든 data 어트리뷰트의 정보를 제공하는 DOMStringMap 객체를 반환.

- DOMStringMap 객체는 data 어트리뷰트의 data- 접두사 다음에 붙인 임의의 이름을 카멜 케이스로 변환한 프로퍼티를 소유, 이 프로퍼티로 data 어트리뷰트의 값을 취득하거나 변경 가능.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul class="users">
      <li id="l" data-user-id="7621" data-role="admin">Lee</li>
      <li id="2" data-user-id="9524" data-role="subscriber">Kim</li>
    </ul>
    <script>
      const users = [... document.querySelector('.users').children];

      // user-id가 '7621'인 요소 노드를 취득.
      const user = users.find(user => user.dataset.userid === '7621');

      // user-id가 '7621'인 요소 노드에서 data-role의 값을 취득. 
      console.log(user.dataset.role); // "admin"

      // user-id가 '7621'인 요소 노드의 data-role 값을 변경.
      user.dataset.role = 'subscriber';

      // dataset 프로퍼티는 DOMStringMap 객체를 반환.
      console.log(user.dataset); // DOMStringMap {userid: "7621", role: "subscriber"} 
    </script>
  </body>
</html>
```

- data 어트리뷰트의 data- 접두사 다음에 존재하지 않는 이름을 키로 사용하여 dataset 프로퍼티에 값을 할당하면 HTML 요소에 data 어트리뷰트가 추가.

- 이때 dataset 프로퍼티에 추가한 카멜케이스의 프로퍼티 키는 data 어트리뷰트의 data- 접두사 다음에 케밥케이스로 자동 변경되어 추가.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul class="users">
      <li id="l" data-user-id="7621" data-role="admin">Lee</li>
      <li id="2" data-user-id="9524" data-role="subscriber">Kim</li>
    </ul>
    <script>
      const users = [ ... document.querySelector('.users').children];

      // user-id가 '7621'인 요소 노드를 취득한다.
      const user = users.find(user => user.dataset.userid === '7621');


      // user-id가 '7621'인 요소 노드에 새로운 data 어트리뷰트를 추가한다.
      user.dataset.role = 'admin';
      console.log(user.dataset);
      /*
        DOMStringMap {userid: "7621", role: "admin"}
        —> <li id="l" data-user-id="7621" data-role="admin">Lee</li> 
      */
    </script>
  </body>
</html>
```
<br>
