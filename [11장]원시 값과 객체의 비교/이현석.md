# 11장. 원시 값과 객체의 비교

- **원시 타입**

  - 변경 불가능한 값.
 
  - 변수에 할당하면 변수에는 실제 값이 저장.
 
  - 다른 변수에 할당하면 원시 값 자신이 복사되어 전달.**(값에 의한 전달)**

- **객체 타입**

  - 변경 가능한 값.
 
  - 변수에 할당하면 변수에는 참조 값이 저장.
 
  - 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달. **(참조에 의한 전달)**
<br>

## 11 - 1. 원시 값

### 11 - 1 - 1. 변경 불가능한 값

- 한번 생성된 원시 값은 읽기 전용 값으로서 변경 불가능.

- 변경 불가능 하다는 것은 변수가 아니라 값이 때문.

- 그렇기에 데이터의 신뢰성을 보장.

```jsx
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다. 
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;

console.log（o）; // {a： 1}
```
<br>

### 11 - 1 - 2. 문자열과 불변성

- 원시 값을 저장하려면 **메모리 공간의 크기를 결정,** 원시 타입별로 메모리 공간의 크기가 존재.

- ECMAScript 사양에 **문자열 타입(2바이트)** 과 **숫자 타입(8바이트)**, 그 외에는 브라우저에 따라 다르고 규명 X.

```jsx
// 문자열은 0개 이상의 문자로 이뤄진 집합이다.
var strl = '';       // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2 = 'Hello'; // 5개의 문자로 이뤄진 문자열
```
<br>

- **C언어**에는 하나의 문자를 위한 데이터 타입(char)만 있을 뿐 문자열 타입은 존재 X, 문자열을 문자의 배열로 처리.

- **JAVA**에서는 문자열을 String 객체로 처리.

- **자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공.**

- **문자열은** 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근 가능.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/121d4572-830b-482a-bc7e-4348a81ddfd1">
</div>
<br>

### 11 - 1 - 3. 값에 의한 전달

- 값에 의한 전달은 변수에 메모리 주소가 전달. (식별자는 값이 아니라 메모리 주소를 기억)

  - 즉, 메모리 주소에 붙은 이름이 식별자.
 
-  전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조 가능.

-  두 변수의 원시 값은 서로 다른 메모리 공간에 저장, 별개의 값이 되어 재할당을 통해 값을 변경하더라도 서로 간섭 X.
<br>

## 11 - 2. 객체

- 동적으로 추가 삭제 가능.

- 값에 제약이 없어서 확보해야 할 메모리 공간의 크기 존재 X.

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/3be09d90-83e5-4525-bd63-2161f5c8de71">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/0da39d52-8f58-4160-850f-a5afaf72962d">
</div>
<br>

### 11 - 2 - 1. 변경 가능한 값

- 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값에 접근.**(메모리 공간의 주소)

  - **원시 값**은 "어떠한 값을 갖는다. or 어떠한 값이다."

  - **객체 값**은 "어떠한 객체를 참조하고 있다. or 어떠한 객체를 가르키고 있다."

- **객체는 재할당 없이** 프로퍼티를 동적으로 추가, 프로퍼티 값을 갱신, 프로퍼티 자체를 삭제 가능.

  - 객체의 크기가 정해져 있지 않기 때문에 원시 값과 같이 복사 후 생성이 불가.
 
  - 이는 복사 시에 메모리 사용이 비효율적이기에 변경 가능한 값으로 설계.
 
  - 이로인한 단점으로 **여러개의 식별자가 하나의 객체를 공유하는 것이 가능.**

```jsx
var person = {
  name: 'Lee'
}；

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name： "Kim", address: "Seoul"}
```
<br>

<div align="center">
  <img src="https://github.com/BrightSton/JS-deep-dive-study/assets/105143449/4d8482b0-0424-4865-a756-eb4a3c395e39">
</div>
<br>


### 11 - 2 - 2. 참조에 의한 전달

- 저장된 메모리 주소는 다르지만 동일한 참조 값을 가지기 때문에 **하나의 객체를 공유한다는 것을 의미**하고 변경시 영향을 주고 받음.

- **값에 의한 전달**과 **참조에 의한 전달**은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일.

  - 다만 변수에 저장되어 있는 값이 **원시 값**이냐, **참조 값**이냐의 차이만 존재.
 
  - 즉, **참조에 의한 전달이 아닌 값에 의한 전달만이 존재.**

```jsx
var person = {
  name: 'Lee'
}；

// 참조 값을 복사(얕은 복사). copy와 person은 동일한 참조 값을 갖는다. 
var copy = person;

// copy와 person 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다. 
person.address = 'Seoul';

// copy와 person 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name： "Kim", address: "Seoul"} 
console.log(copy);  // {name: "Kim", address: "Seoul"}
```
<br>
