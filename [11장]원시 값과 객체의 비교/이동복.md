# 11장 원시 값과 객체의 비교

|원시 타입 | 객체 타입 |
|---|---|
| 원시 값은 변경 불가능하다. | 객체 타입의 값은 변경 가능하다. |
| 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. | 객체를 변수에 할당하면 변수에 참조 값이 저장된다. |
| 원시 값이 할당된 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. = 값에 의한 전달 | 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. = 참조에 의한 전달 |
 
## 11.1 원시 값 

### 11.1.1 변경 불가능한 값

**원시 타입의 값은 변경 불가능한 값으로 한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없다.**

원시 타입의 값이 할당된 변수는 원시 값을 가르키는 메모리 주소 값을 가진다.
따라서 **변경 불가능하다는 것은 변수가 아닌 값에 대한 진술이다.**

- 변수는 표현식이 평가된 값을 가지며 언제든지 재할당하여 변수 값을 변경할 수 있다.
- 변수의 반대 개념인 상수는 재할당이 금지된 변수이다. 최초 값이 저장된 메모리 공간이 필요하여 변수라고 할 수 있다.
- 상수는 재할당이 금지된 변수일 뿐 변경 불가능한 값을 의미하는 것은 아니다.

```javascript
// const 키워드를 사용하여 선언된 변수는 재할당이 금지된다.
const o = {};

// 상수 변수에 할당된 원시 값은 변경될 수 없다.
// 상수 변수에 할당된 객체는 변경 가능하다.
o.a = 1;
console.log(o); // {a: 1}
```

- 원시 값은 변경 불가능한 값으로 데이터의 신뢰성을 보장한다.
- 원시 값이 할당된 변수에 다른 원시 값을 재할당하면 기존에 원시 값을 가르키던 메모리 주소를 해제하고,
새로운 메모리 공간을 확보하여 원시 값을 저장하고 새로 할당된 원시 값을 가르키는 주소를 참조한다.
- 재할당 시 메모리 공간의 주소가 변경되는 것은 원시 값의 불변성 때문이다.
- 만약 원시 값이 변경 가능한 값이라면 새로운 메모리 주소를 할당할 필요 없이 해당 메모리의 원시 값을 변경하면 될 것이다.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

### 11.1.2 문자열과 불변성

- 메모리 공간의 크기는 원시 타입 별로 메모리 공간의 크기가 미리 정해져있다.
-ECMAScript 사양에서 문자열 타입(2바이트)과 숫자 타입(8바이트) 이외의 원시 타입은 
크기를 명확히 규정하지 않아 원시 타입의 크기는 다를 수 있다.
- 원시 값인 문자열은 0개 이상의 문자로 이뤄진 집합으로 1개의 문자는 2바이트의 공간에 저장된다.
- 숫자 값은 1이나 10000000도 동일한 8바이트가 필요하지만 문자열은 문자의 갯수 x 2바이트의 공간이 필요하다.
- 문자열 값 또한 변경 불가능한 값이다.

	유사 배열 객체
	배열과 같이 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다.
	length 프로퍼티를 갖기 때문에 유사 객체이며 for 문으로 순회 가능하다.
	
	```javascript
	var text = 'text';
	
	console.log(text[1]); // e

	// 문자열은 원시 값으로 변경될 수 없으며 이 때, 에러는 발생하지 않는다.
	text[2] = 'S';
	
	console.log(text.length); // 4
	console.log(text.toUpperCase()); // TEXT
	```

### 11.1.3 값에 의한 전달

```javascript
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 전달되는데 이를 **값에 의한 전달**이라 한다.
score와 copy의 평가된 값과 타입은 같지만 서로 다른 메모리 주소 값을 갖는다.
즉, 변수에 할당된 원시 값을 새로운 메모리 주소에 복사하는 것이다. 참조 값이 서로 같은 것이 아니므로 변수 서로에게 영향도는 없다.

자바스크립트 엔진 내부 동작 방식에는 차이가 있을 수 있다.
1. 원시 값을 가진 변수를 할당 받는 시점부터 이미 새로운 메모리 주소를 확보하여 원시 값을 복사하는 경우
2. 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이루어질 때 새로운 메모리 공간에 재할당된 값을 저장하는 경우

```javascript
var score = 80;
// 전자의 경우 할당될 때부터 서로 다른 메모리 주소를 바라봄
// 후자의 경우 이 시점에 서로 같은 메모리 주소를 바라보고 있음
var copy = score;

console.log(score); // 80
console.log(copy); // 80

// 후자의 경우에 메모리 공간에 재할당되는 시점
score = 100;

console.log(score); // 100
console.log(copy); // 80
```

## 11.2 객체

객체는 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가되며 삭제될 수 있다. 또한 프로퍼티의 값도 제약이 없다.
따라서, 객체를 생성하고 프로퍼티에 접근하는 것도 비용이 많이 드는 일이다.
당연히도 원시 값과 다른 방식으로 동작하도록 설계되어 있다.

	자바스크립트 객체의 관리 방식
	자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
	자바스크립트는 클래스 없이 객체를 생성할 수 있고 객체가 생성된 이후에도 동적으로 프로퍼티나 메서드를 추가할 수 있다.
	이는 사용 면에서 편의성을 제공하지만 성능 면에서는 객체 지향 프로그래밍 언어의 객체(클래스를 미리 설계, 선언하여 사용)보다 생성과 프로퍼티 접근 비용이 더 크게 발생한다.
	따라서 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스 방식(클래스와 유사하게 동작)을 사용하여 비효율 부분을 어느정도 개선하였다.

### 11.2.1 변경 가능한 값

**객체(참조) 타입의 값은 변경 가능하다.**

```javascript
// 할당 시점에 객체 리터럴이 해석되어 객체가 생성된다.
var person = {
	name: 'Lee'
};

console.log(person); // {name: "Lee"}

// 객체는 변경 가능한 값으로 프로퍼티 변경, 추가, 삭제 등이 가능하다.
person.name = 'Kim';
person.address = 'Incheon';

console.log(person); //{name: "Kim", address: "Incheon"}
```

**여러 개의 식별자가 하나의 객체를 공유할 수 있다.** 는 것은 객체의 구조적 단점의 부작용이다.

	얕은 복사와 깊은 복사
	얕은 복사: 중첩된 객체의 참조 값을 복사하는 것. ( 스프레드 문법 등 )
	깊은 복사: 중첩된 객체 모두를 복사하는 것. (Node.js의 lodash 등 )
	
	* 원시 값이 할당된 변수를 다른 변수에 할당하는 것을 깊은 복사
	  객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 하기도 한다.
		
```javascript
const o1 = { a: { b : 1 }};
const o2 = { ...o1 };

// o1과 o2의 참조변수는 다르다.
console.log(o1 === o2); // false
// o1 객체의 1차 객체의 참조 변수를 공유한다.
console.log(o1.a === o2.a); // true

// o1 객체의 a 값을 변경한다.
o1.a.b = 2;
// o1 객체에 프로퍼티 c를 동적으로 추가한다.
o1.c = 3;

// o1 객체의 프로퍼티 a값이 바뀌었어도 1차 객체 참조변수를 공유하므로
// o2 객체의 프로퍼티 a값 또한 변경된다. 
// 쉽게 말하면 1차 객체의 값이 변경되더라도  1차 객체 a의 메모리 주소 값을 공유하고 있다.
console.log(o1.a === o2.a); // true	
console.log(o2);

// o1 객체의 프로퍼티 a값을 재할당한다.
o1.a = { d: 4 };
console.log(o1.a); // { a: { d: 4}, c: 3 }
// o1 객체 프로퍼티 a 값의 주소는 재할당으로 분리되어 더 이상 공유되지 않는다.
// o1 객체 프로퍼티 a 값의 주소를 공유하고 있던 당시의 값으로 고정되어 있다.
console.log(o2.a); // { a: { b: 2} }

// 따라서 더 이상 프로퍼티 a의 메모리 주소 값은 동일하지 않다.
console.log(o1.a === o2.a); // false

console.log(o1); // { a: { d: 4 }, c: 3}
console.log(o2); // { a: { b: 2} }
```
	
### 11.2.2 참조에 의한 전달

```javascript
var person = {
	name: 'Lee'
}

// 참조 값을 복사 ( 얕은 복사 )
// 객체를 가르키는 원본 변수를 다른 변수에 할당하는 것
var copy = person;

console.log(person === copy);

person.name = 'Kim';
person.address = 'Incheon';

// 서로 같은 객체의 참조 값을 갖고 있어 서로 영향을 받는다.
console.log(person); // { name: 'Kim', address: 'Incheon'}
console.log(address); // { name: 'Kim', address: 'Incheon'}
```

**참조 값이 복사되어 잔달되는 것을 참조에 의한 전달이라고 한다.**
