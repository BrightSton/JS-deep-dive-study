26장 ES6 함수의 추가 기능
=================================================================

# 26-1. 함수의 구분

ES6 이전 자바스크립트의 함수
1. 일반적인 함수
2. new 연산자와 함께 호출하여, 인스턴스를 생성할 수 있는 생성자 함수
3. 객체에 바인딩된 메서드

```javascript
var foo = function () {
    return 1;
};

// 1. 일반적인 함수
foo();  // --> 1

// 2. 생성자 함수
new foo();  // --> foo {}

// 3. 메서드
var obj = { foo: foo };
obj.foo();  // --> 1
```

ES6 이전의 모든 함수는 사용 목적에 따라 명확히 구분 X

````javascript
var foo = function () {};

// ES6 이전의 모든 함수는 callable 이면서 constructor 다.
foo();  // --> undefined
new foo();  // --> foo {}
````

> [ callable 과 constructor / non-constructor ]
> - 17-2-4. 내부 메서드 [[Call]] 과 [[Construct]] 에서 살펴보았듯이, 
> - 호출할 수 있는 함수 객체 = callable
> - 인스턴스를 생성할 수 있는 함수 객체 = constructor
> - 인스턴스를 생성할 수 없는 함수 객체 = non-constructor

### 주의할 것
: ES6 이전에, 일반적으로 메서드라고 부르던 객체에 바인딩된 함수도 callable 이며 constructor !
: so 객체에 바인딩된 함수도 일반 함수로서도, 생성자 함수로서도 호출 가능

```javascript
// 프로퍼티 f 에 바인딩된 함수는 callable 이며 constructor 다.
var obj = {
    x: 10,
    f: function () { return this.x; }
};

// 프로퍼티 f 에 바인딩된 함수를 메서드로서 호출
console.log(obj.f());  // 10

// 프로퍼티 f 에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar());  // undefined

// 프로퍼티 f 에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f());  // f {}
```

- 이는 성능 면에서 문제가 있다.
  - 객체에 바인딩된 함수가 constructor 라는 것 = 객체에 바인딩된 함수가 prototype 프로퍼티를 가짐 + 프로토타입 객체를 생성함
- 콜백 함수도 마찬가지로 불필요한 프로토타입 객체를 생성함

```javascript
// 콜백 함수를 사용하는 고차 함수 map.
// 콜백 함수도 constructor 이며 프로토타입을 생성함
[1, 2, 3].map(function (item) {
    return item * 2;
}) // --> [2, 4, 6]
```

- 이처럼 ES6 이전의 모든 함수는, 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성함
  - 해결하기 위해 ES6 에서 함수를 사용 목적에 따라 3 가지 종류로 명확히 구분함


| ES6 함수의 구분    | constructor | prototype | super | arguments |
|:--------------|:-----------:|:---------:|:-----:|:---------:|
| 일반 함수(Normal) |      O      |     O     |   X   |     O     |          
| 메서드(Method)   |      X      |     X     |   O   |     O     | 
| 화살표 함수(Arrow) |      X      |     X     |   X   |     X     |


- 일반함수
  - 함수 선언문 or 함수 표현식 으로 정의한 함수
  - ES6 이전의 함수와 차이 X
- ES6 메서드, 화살표 함수
  - 명확한 차이 O
  - non-constructor



















