27장 배열

# 배열

## 배열이란?
여러 개의 값을 순차적으로 나열한 자료구조

```javascript
const arr = [apple, banana, cherry];
```
- `요소` : 배열을 구성하는 각 값 / 원시값, 객체, 함수 등 모든 자료형 가능   
- `인덱스` : 요소의 위치를 나타내는 숫자 / 0부터 시작  
- `길이` : 배열의 길이는 요소의 개수로 결정 / `length` 프로퍼티로 확인 가능

⚠ 배열이라는 타입은 없다. 배열은 객체의 일종이다.
```javascript
console.log(typeof [1, 2, 3]); // object
```

> #### 배열의 장점
> 배열은 값의 순서와 length 프로퍼티를 갖고 있음
> - 처음부터 순차적으로 요소에 접근 가능 / 마지막부터 역순으로 요소에 접근 가능
> - 특정 위치부터 순차적으로 요소에 접근 가능


## ⚠️ 자바스크립트 배열은 배열이 아니다
자바스크립트에서 배열은 사실 배열이 아니라 일반적인 `배열의 동작을 흉내낸 객체`임

> **일반적인 배열 (C, Java)**
> - 고정된 크기를 가짐
> - 동일한 데이터 타입의 요소만 저장 가능
> - 메모리 상에 연속적으로 배치됨 (배열 요소가 `밀집 배열`임)
> - 인덱스를 통해 요소에 빠르게 접근 가능

> **자바스크립트 배열**
> - 동적으로 크기가 변함
> - 다양한 데이터 타입의 요소 저장 가능
> - 객체의 특수한 형태로, 인덱스를 키로 사용하여 값 저장
> - 메모리 상에 연속적으로 배치되지 않을 수 있음 (배열 요소가 `희소 배열`일 수 있음)
> - 배열 전용 메서드와 프로퍼티 제공
> - 해시 테이블로 구현된 객체라서 인덱스를 통해 요소에 접근할 때 일반적인 배열보다 느리지만 요소를 삽입하거나 삭제하는 연산은 빠름



## `length` 프로퍼티와 희소 배열
`length` 프로퍼티:  배열의 길이를 나타내는 프로퍼티
- 길이는 0부터 시작하는 배열의 인덱스보다 1 큰 값
- `length` 프로퍼티를 통해 배열의 길이를 동적으로 변경 가능

```javascript
const arr = [1, 2, 3];
console.log(arr.length); // 3

/* 요소 추가 */
arr.push(4);
console.log(arr.length); // 4

/* 요소 삭제 */
arr.pop();
console.log(arr.length); // 3
```

```javascript
const arr = [1, 2, 3, 4, 5];

/* length 프로퍼티 변경 */
arr.length = 3;

console.log(arr); // [1, 2, 3]
```

```javascript
const arr = [1];

/* length 프로퍼티보다 큰 값으로 변경 */
arr.length = 3;

// length 프로퍼티 값은 변경되지만 실제로 뱌ㅐ열의 길이가 늘어나지는 않는다.
console.log(arr.length); // 3

// 희소 배열
// 값 없이 비어있는 요소를 위해 메모리 공간을 확보하지 않고 빈 요소를 생성하지 않는 상태
console.log(arr); // [1, empty, empty]
```

`희소 배열`: 배열 요소의 인덱스가 연속적이지 않은 배열
- 배열 요소가 연속적이지 않아 메모리 낭비가 발생할 수 있음
- 같은 타입의 요소를 연속적으로 위치시키는 게 좋음


## 배열 생성
### 배열 리터럴
`배열 리터럴`: 대괄호 `[]`를 사용해 배열을 생성하는 방법

```javascript
const arr = [1, 2, 3];
console.log(arr.length); // 3
```

```javascript
const arr = [];
console.log(arr.length); // 0
```

```javascript
/* 희소 배열 */
const arr = [1, , 3];
console.log(arr.length); // 3
console.log(arr); // [1, empty, 3]
// 프로퍼티 키가 '1'인 요소가 없기 때문에 empty로 표시 & undefined로 취급
console.log(arr[1]); // undefined
```

### Array 생성자 함수
`Array 생성자 함수`: `new` 연산자와 함께 호출하여 배열을 생성하는 방법
- 인수가 1개이고 숫자인 경우: 인수를 길이로 갖는 빈 배열 생성
    ```javascript
    /* 희소 배열 */
    const arr = new Array(10);
    console.log(arr); // [ <10 empty items> ]
    console.log(arr.length); // 10
    console.log(Object.getOwnPropertyDescriptors(arr)); // { '0': { value: undefined, writable: true, enumerable: true, configurable: true }, length: { value: 10, writable: true, enumerable: false, configurable: false } }
    ```
- 인수가 4294967295보다 크거나 음수인 경우: `RangeError` 발생

- 인수가 2개 이상이거나 인수가 숫자가 아닌 경우: 인수를 요소로 갖는 배열 생성
    ```javascript
    const arr = new Array(1, 2, 3); // [1, 2, 3]
    
    new Array({}); // [ {} ] 
  
  // Array 생성자 함수 내부에서 new.target을 확인하기 때문에 new 없어도 생성 가능 
    Array(1, 2, 3) // [1, 2, 3]
    ```
  
### `Array.of`
`Array.of`: 전달된 인수를 요소로 갖는 배열을 생성하는 정적 메서드
- 인수의 개수와 타입에 관계없이 배열 생성: Array.of는 전달된 인수들을 그대로 요소로 갖는 배열을 생성
- 일관된 동작: Array 생성자 함수와 달리, 인수가 하나일 때도 해당 인수를 요소로 갖는 배열을 생성

Array 생성자 함수와 다른 점: 인수의 개수나 타입에 관계없이 항상 새로운 배열을 생성  
➡️ `Array.of`가 더 직관적이고 예측 가능한 방법으로 배열 생성이 가능함

```javascript
Array.of(1); // [1]
Array.of(1, 2, 3); // [1, 2, 3]
Array.of('string'); // ['string']
Array.of(); // []
```

### `Array.from`
`Array.from`: 유사 배열 객체나 이터러블 객체를 변환하여 배열을 생성

#### 유사 배열 객체
- length 프로퍼티를 갖는 객체 
- 인덱스로 프로퍼티 값에 접근 가능
- 실제 배열은 아니기 때문에 배열 메서드 사용 불가능
- `for`문으로 순회 가능

#### 이터러블 객체
- 반복 가능한 객체
- `Symbol.iterator` 메서드를 구현하고 있음
- 스프레드 문법, `Array.from` 메서드 등으로 배열로 변환 가능
- `for...of` 문으로 순회 가능


## 배열 요소의 참조
배열 요소에 접근하는 방법
```javascript
const arr = [1, 2];

// 인덱스가 0인 요소에 접근
console.log(arr[0]); // 1

// 인덱스가 2인 요소에 접근
// 희소 배열에서 존재하지 않는 요소도 undefined
console.log(arr[2]); // undefined
```


## 배열 요소의 추가와 갱신
배열에 요소를 동적으로 추가할 수 있음
- 존재하지 않는 인덱스에 값을 할당하면 배열의 길이가 늘어남
- 이 때 length 프로퍼티 값이 자동 갱신됨
- length 프로퍼티 값 보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 됨
- 이미 존재하는 인덱스에 값을 할당하면 요소의 값이 갱신됨


## 배열 요소의 삭제
배열의 특정 요소를 삭제 하기 위해 `delete` 연산자 사용

```javascript
const arr = [1, 2, 3];
arr.splice(1, 1);
console.log(arr); // [1, 3]
console.log(arr.length); // 2
```