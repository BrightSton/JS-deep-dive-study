# 배열

## 27.1 배열이란?

- 배열은 여러 개의 값을 순차적으로 나열한 사용 빈도가 매우 높은 자료구조로 자바스크립트는 배열을 다루기 위한 유용한 메서드를 다수 제공.

- 배열의 값은 **요소**로, 자바스크립트의 모든 값이 요소가 될 수 있으며, 원시값, 객체, 함수, 배열 등 값으로 인정하는 모든 것이 배열의 요소 가능.

- 배열의 요소는 배열에서 자신의 위치를 나타내는 0 이상의 정수인 **인덱스**를 가지며, 배열의 요소에 접근할 때 사용.(대부분의 프로그래밍 언어에서 인덱스는 0부터 시작)

- 배열은 요소의 개수인 배열의 길이를 나타내는 **length 프로퍼티**를 소유하고 for 문을 통해 순차적으로 요소에 접근 가능.

```jsx
// 배열의 순회
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 'apple' 'banana ' 'orange'
}
```

- 배열이라는 타입은 존재하지 않으며, 배열은 객체 타입에 소속.

- 배열은 배열 리터럴，Array 생성자 함수, Array.of, Array.from 메서드로 생성 가능.

```jsx
typeof arr // 一 object

const arr = [1, 2, 3];
arr.constructor === Array // — true
Object.getPrototypeOf(arr) === Array.prototype // — true
```

- 배열은 객체지만 일반 객체와는 구별되는 독특한 특징 소유.

<div align="center">
  <img src="https://github.com/user-attachments/assets/bc20a5d2-003c-4649-a242-f71d3e8e894f">
</div>

- 일반 객체와 배열을 구분하는 가장 명확한 차이로 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조.

  - **값의 순서** : 인덱스로 표현되는 값.

  - **length 프로퍼티** : 인덱스로 표현되는 값
 
  - **장점** : 처음부터 순차적으로 요소에 접근 가능하고, 끝에서 부터 역순으로 요소에 접근 가능 하며, 특정 위치에서도 순차적으로 요소에 접근 가능.

```jsx
const arr = [1, 2, 3];

// 반복문으로 자료구조률 순서대로 순회하기 위해서는 자료구조의 요소에 순서대로 잡근할 수 있어야 하며
// 자료구조의 길이를 알 수 있어야 한다.
for (let i 0; i < arr.length; i++) {
  console.log(arr[i]); // l 2 3
}  
```
<br>

## 27.2 자바스크립트 배열은 배열이 아니다

- 자료구조에서의 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조로, 배열의 요소가 하나의 데이터 타입으로 통일되어 있고 서로 연속적으로 인접.(밀집 배열)

<div align="center">
  <img src="https://github.com/user-attachments/assets/d2302215-d13a-4eb1-a542-9cb265b0c59b">
</div>

- 일반적 의미의 배열은 각 요소가 동일한 데이터 크기를 가지며, 연속적으로 이어져 있어 다음과 같이 인덱스를 통해 한 번의 연산으로 임의의 요소에 접근 가능.(임의 접근)

  - `검색 대상 요소의 메모리 주소 = 배열의 사작 메모리 주소 + 인덱스 * 요소의 바아트 수`
 
- 정렬되지 않은 배열에서 특정 요소 검색의 경우 배열의 모든 요소부터 특정 요소를 발견할 때까지 차례 검색 필요.(선형 검색)

```jsx
// 선형 검색을 통해 배열(array)에 특정 요소(target)가 존재하는지 확인.
// 배열에 특정 요소가 존재하면 특정 요소의 인덱스를 반환, 존재하지 않으면 -1을 반환.
function linearSearch(array, target) {
  const length = array.length;
  for (let i = 0; i < length; i++) {
    if (array[i] === target) return i;
  }
  return -1;
}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
```

- 배열에 요소를 삽입 or 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소 이동을 해줘야 하는 단점 존재.

<div align="center">
  <img src="https://github.com/user-attachments/assets/7b6c5c20-e6dd-4663-8127-6c586427f679">
</div>

- 자바스크립트의 배열은 자료구조에서의 일반적 의미의 배열과 달리 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 불연속적일 가능성 존재.(희소 배열)

- **자바스크립트의 배열은 일반적인 배열의 동작을 홍내 낸 특수한 객체.**

```jsx
// 16.2절 "프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체" 참고
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true}
  '1': {value: 2, writable: true, enumerable: true, configurable: true
  '2': {value: 3, writable: true, enumerable: true, configurable: true
  length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

- 자바스크립트 배열의 요소는 사실 프로퍼티 값으로 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소로 가능.

```jsx
const arr = [
  'string',
  10,
  true,
  null,
  undefined,
  NaN,
  Infinity,
  [ ],
  { },
  function () {}
];
```

- 일반적인 배열과 자바스크립트 배열의 장단점을 정리.

  - 일반적인 배열은 인덱스로 요소에 빠르게 접근 가능 하지만 요소를 십입 또는 삭제하는 경우에는 비효율적.
 
  - 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느리다는 단점이있지만 요소를 삽입 or 삭제하는 경우 일반적인 배열보다 효율적.
<br>

## 27.3 length 프로퍼티와 희소 배열

- length 프로퍼티의 값은 빈 배열일 경우 0이며, 빈 배열이 아닐 경우 가장 큰 인덱스에 1을 더한 것과 동일.

```jsx
[ ].length // - 0
[1, 2, 3].length // - 3
```

- length 프로퍼티의 값은 배열에 요소를 추가 or 삭제 시 자동 갱신.

```jsx
const arr = [1, 2, 3];
console.log(arr.length); // 3

// 요소 추가
arr.push(4);
// 요소를 추가하면 length 프로퍼티의 값이 자동 갱신.
console.log(arr.length); // 4

// 요소 삭제
arr.pop();
// 요소를 삭제하면 length 프로퍼티의 값이 자동 갱신.
console.log(arr.length); // 3
```

- length 프로퍼티 값은 요소의 개수，즉 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당 가능.

```jsx
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티 값인 5보다 작은 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 단축.
console.log(arr); // [l, 2, 3]
```

- length 프로퍼티 값보다 큰 숫자 값을 할당하는 경우, length 프로퍼티 값은 변경되지만 실제로 배열의 길이 증가 X.

```jsx
const arr = [1];

// 현재 length 프로퍼티 값인 1보다 큰 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// length 프로퍼티 값은 변경되지만 실제로 배열의 길이 증가 X.
console.log(arr.length); // 3
console.log(arr); // [l, empty * 2]

console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
'0': {value: 1, writable: true, enumerable: true, configurable: true},
length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

- 일반적인 배열의 length는 배열 요소의 개수, 즉 배열의 길이와 언제나 일치.

- but, 희소 배열은 length와 배열 요소의 개수가 일치하지 않으며, 희소 배열의 실제 요소 개수보다 큼.

- 배열 생성 시 희소 배열을 생성치 않도록 주의하고, 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선.
<br>

## 27.4 배열 생성

### 27.3.1 배열 리터럴

- 일반적이고 간편한 배열 생성 방식은 배열 리터럴 사용으로 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재.

```jsx
const arr : [1, 2, 3];
console.log(arr.length); // 3
```

- 배열 리터럴에 요소를 하나도 추가하지 않으면 배열의 길이인 length 프로퍼티 값이 0인 빈 배열.

```jsx
const arr = [];
console.log(arr.length); // 0
```

- 배열 리터럴에 요소를 생략하면 희소 배열 생성.

```jsx
const arr [1, , 3]; // 희소 배열

// 희소 배열의 length는 배열의 실제 요소 개수보다 언제나 크다.
console.log(arr.length); // 3
console.log(arr); // [1, empty, 3]
consote.1og(arr[l]); // undefined
```
<br>

### 27.4.2 Array 생성자 함수

- Object 생성자 함수를 통해 객체를 생성할 수 있듯이 Array 생성자 함수를 통해 배열을 생성 가능.

- Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작하므로 주의가 필요.

  - 전달된 인수가 1개이고 숫자인 경우 length 프로퍼티 값이 인수인 배열을 생성.

  ```jsx
  const arr = new Array(10);
  console.log(arr); // [empty x 10]
  console.1og(arr.length); // 10
  ```

  - 이때 생성된 배열은 희소 배열로, length 프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재 X.

  ```jsx
  console.log(Object.getOwnPropertyDescriptors(arr));
  /*
  {
    length: {value: 10, writable: true, enumerable: false, configurable: false}
  }
  */
  ```

  - 배열은 요소를 최대 `2**32 - 1(4,294.967,295)개` 소유 가능하기에 Array 생성자 함수에 전달할 인수는 0 or `2**32 - 1 (4,294,967,295)` 이하인 양의 정수로 인수 범위를 벗어나면 RangeError 발생.

  ```jsx
  // 배열은 요소를 최대 4,294,967,295개 가질 수 있다.
  new Array(4294967295);
  
  // 전달된 인수가 0 〜 4,294,967,295를 벗어나면 RangeError 발생.
  new Array(4294967296); // RangeError: Invalid array length
  
  // 전달된 인수가 음수이면 에러가 발생.
  new Array(-l); // RangeError: Invalid array length
  ```

  - 전달된 인수가 없는 경우 빈 배열을 생성, 전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 사、무 갖는 배열을 생성.

  ```jsx
  new Array(); // — []
  
  // 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열 생성.
  new Array(l, 2, 3); // - [1, 2, 3]
  
  // 전달된 인수가 1개지만 숫자가 아니면 인수를 요소로 갖는 배열 생성.
  new Array({}); / - [{}]
  ```

  - Array 생성자 함수는 new 연산자와 함께 호출하지 않더라도 배열을 생성하는 생성자 함수로 동작하는데, 이는 Array 생성자 함수 내부에서 new.target을 획인하기 때문.
<br>

### 27.4.3 Array.of

- ES6에서 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열 생성.

- Array.of는 Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열 생성.

```jsx
// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열 생성.
Array.of(l); // — [1]

Array.of(l, 2, 3); // — [l, 2, 3]

Array.of('string'); // — ['string']
```
<br>

### 27.4.4 Array.from

- ES6에서 도입된 Array.from 메서드는 유사 배열 객체 or 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환.

```jsx
// 유사 배열 객체를 변환하여 배열 생성.
Array.from({ length: 2, 0: 'a', 1： 'b' }); // - ['a', 'b']

// 이터러블을 변환하여 배열을 생성, 문자열은 이터러블.
Array. from('Hello'); // 一 ['H'，'e', 'l', 'l', 'o']
```

- Array.from을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소 생성.

- 두 번째 인수로 전달한 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달하면서 호출, 콜백 함수의 반환값으로 구성된 배열을 반환.

```jsx
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 생성.
Array.from({ length: 3 }); "— [undefined, undefined, undefined]

// Array.from은 두 번째 안수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환.
Array.from({ length: 3 }, (_, i) => i); // — [0, 1, 2]
```
<div align="center">
  <img src="https://github.com/user-attachments/assets/dccd7a3d-7878-4186-b63c-4c1ecd8b2ef8">
</div>
<br>

## 27.5 배열 요소의 참조

- 배열의 요소를 참조할 때 대괄호([]) 표기법을 사용하며, 정수로 평가되는 표현식이라면 인덱스 대신 사용가능하고, 값을 참조할 수 있다는 의미에서 객체의 프로퍼티 키와 같은 역할 수행.

```jsx
const arr = [1, 2];

// 인덱스가 0인 요소를 참조
console.log(arr[0]); // 1

// 인덱스가 1인 요소를 참조
console.log(arr[l]); // 2
```

- 존재하지 않는 요소에 접근하면 undefined가 반환.

```jsx
const arr = [1, 2];
// 인덱스가 2인 요소를 참조. 배열 arr에는 인덱스가 2인 요소가 존재 X.
console.1og(arr[2]); // undefined
```

- 희소 배열의 존재하지 않는 요소를 참조해도 undefined가 반환.

```jsx
// 희소 배열
const arr = [1, , 3];

// 배열 arr에는 인덱스가 1인 요소가 존재 X.
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true},
  '2': {value: 3, writable: true, enumerable: true, configurable: true},
  length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/

// 존재하지 않는 요소를 참조하면 undefined가 반환.
console.1og(arr[l]); // undefined
console.log(arr[3]); // undefined
```
<br>

## 27.6 배열 요소의 추가와 갱신

- 객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가 가능하고 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가되는데, 이때 length 프로퍼티 값은 자동 갱신.

- 만약 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소 추가 시 희소 배열로 변환.

```jsx
const arr = [0];

// 배열 요소의 추가
arr[l] = 1;

console.log(arr); 시 [0, 1]
console.log(arr.length); // 2

arr[100] = 100;

console.log(arr); // [0, 1, empty * 98, 100]
console.log(arr.length); // 101
```

- 이미 요소가 존재하는 요소에 값을 재할당하면 요소값 갱신.

```jsx
// 요소값의 갱신
arr[l] = 10;

console.log(arr); // [0, 10, empty * 98, 100]
```

- 정수 이외의 값을 인덱스처럼 사용하면 요소가 생성되는 것이 아니라 프로퍼티가 생성, 추가된 프로퍼티는 length 프로퍼티 값에 영향 X.

```jsx
const arr = [];

// 배열 요소의 추가
arr[0] = 1;
arr['l'] = 2;

// 프로퍼티 추가
arr['foo'] = 3;
arr.bar = 4;
arr[l.l] = 5;
arr[-l] = 6;

console.log(arr); // [1, 2, foo： 3, bar： 4, '1.1' ： 5, '-1' ： 6]

// 프로퍼티는 length에 영향 X.
console.log(arr.length); // 2
```
<br>

## 27.8 배열 요소의 삭제

- 배열은 사실 객체이기 때문에 배열의 특정 요소를삭제하기 위해 delete 연산자를 사용 가능.

```jsx
const arr = [1, 2, 3];

// 배열 요소의 삭제
delete arr[l];
console.log(arr); // [l, empty, 3]

// length 프로퍼티에 영향을 주지 않는다.(희소 배열)
console.log(arr.length); // 3
```

- 희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메서드를 사용.

```jsx
const arr [1, 2, 3];
// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
// arr[l]부터 1개의 요소를 제거
arr.splice(l, 1);
console.log(arr); // [l, 3]

// length 프로퍼티가 자동 정산.
console.log(arr.length); // 2
```
<br>

## 27.8 배열 메서드

- Array 생성자 함수는 정적 메서드를 제공하며, 배열 객체의 프로토타입인 Array.prototype은 프로토타입 메서드를 제공.

- 배열 메서드는 결과물을 반환하는 패턴이 두 가지이므로 주의가 필요.

  - 배열에는 원본 배열을 직접 변경하는 매서드.
 
  - 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드.

```jsx
const arr = [1];

// push 메서드는 원본 베g(arr)을 직접 변경.
arr.push(2);
console.log(arr); // [l, 2]

// concat 메서드는 원본 배열(arr)을 직접 변경하지 않고 새로운 배열을 생성하여 반환.
const result = arr.concat(3);
console.log(arr); // [l, 2]
console.log(result); // [l, 2, 3]
```

- ES5부터 도입된 배열 메서드는 대부분 원본 배열을 직접 변경하지 않지만 초창기 배열 메서드는 원본 배열을 직접 변경하는 경우 다수.

- 원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수 효과가 있으므로 사용할 때 주의 필요.
<br>

### 27.8.1 Array.isArray

- Array.isArray 메서드는 전달된 인수가 배열이면 true, 배열이 아니면 false를 반환.

```jsx
// true
Array.isArray([]);
Array.isArray([1, 2]);
Array.isArray(new Array());

// false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(l);
Array.isArray('Array1);
Array.isArray(true);
Array.isArray(false);
Array.isArray({ 0： 1, length: 1 })
```
<br>

### 27.8.2 Array.prototype.indexOf

- indexOf 메서드는 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환.

  - 원본 배열에 인수로 전달한 요소와 중복되는 요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환.
 
  - 원본 배열에 인수로 전달한 요소가 존재하지 않으면 -1을 반환.
 
```jsx
const arr = [1, 2, 2, 3];

// 배열 arr어/서 요소 2를 검색하여 첫 번째로 검색된 요소의 인덱스를 반환.
arr.index0f(2); '/ — 1

// 배열 arr에 요소 4가 없으므로 -1을 반환.
arr.index0f(4); // — -1

// 두 번째 인수는 검색을 시작할 인덱스로, 두 번째 인수를 생략하면 처음부터 검색.
arr.index0f(2, 2); // — 2
```

- indexOf 메서드는 배열에 특정 요소가 존재하는지 확인할 때 유용.

```jsx
const foods = ['apple', 'banana', 'orange'];

// foods 배열에 'orange' 요소가 존재하는지 확인.
if (foods.indexOf('orange') === -1) {
  // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가.
  foods.push('orange');
}

console.log(foods); 7 ["apple", "banana", "orange"]
```

- indexOf 메서드 대신 ES7에서 도입된 Array.prototype.includes 메서드를 사용하면 가독성 증가.

```jsx
const foods = ['apple', 'banana', 'orange'];

// foods 배열에 'orange' 요소가 존재하는지 확인.
if (!foods.includes('orange')) {
  // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가.
  foods.push('orange');
}
console.log(foods); 7 ["apple", "banana", "orange"]
```
<br>

### 27.8.3 Array.prototype.push

- push 메서드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환, push 메서드는 원본 배열을 직접 변경.

```jsx
const arr = [1, 2];
// 인수로 전달받은 모든 값을 원본 배열 arr의 마지막 요쇼로 추가하고 변경된 length 값을 반환.

let result = arr.push(3, 4);
console.log(result); // 4

// push 메서드는 원본 배열을 직접 변경.
console.log(arr); // [l, 2, 3, 4]
```

- push 메서드는 성능 면에서 좋지 않은데, 마지막 요소로 추가할 요소가 하나라면 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가 가능.

```jsx
const arr = [1, 2];

// arr.push(3)과 동일한 처리를 한다. 이 방법이 push 메서드보다 빠르다.
arr[arr.length] = 3;
console.log(arr); // [l, 2, 3]
```

- push 메서드는 원본 배열을 직접 변경하는 부수 효과 존재에 따라 push 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 유용.

  - 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과 X.

```jsx
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [... arr, 3];
console.log(newArr); // [l, 2, 3]
```
<br>

### 27.8.4 Array.prototype.pop

- pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환하는데, 원본 배열이 빈 배열이면 undefined를 반환.(원본 배열을 직접 변경)

```jsx
const arr = [1, 2];

// 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환.
let result = arr.pop();
console.log(result); // 2

// pop 메서드는 원본 배열을 직접 변경.
console.log(arr); // [1]
```

- pop 메서드와 push 메서드 사용을 통해 스택 구현 가능.

  - 스택은 데이터를 마지막에 밀어 넣고，마지막에 밀어 넣은 데이터를 먼저 꺼내는 후입 선출(LIFO - LastIn First Out) 방식의 자료구조.
 
  - 스택에 데이터를 밀어 넣는 것을 푸시(push), 스택에서 데이터를 꺼내는 것을 팝(pop).

  <div align="center">
    <img src="https://github.com/user-attachments/assets/ecc8b489-6f47-4314-b7d3-51e064cfd7af">
  </div>

```jsx
const Stack = (function () {
  function Stack(array = []) {
    if (!Array.isArray(array)) {
      // 47장 "에러 처리" 참고
      throw new TypeError( ${array} is not an array.');
    }
    this.array = array;
  }

  Stack.prototype = {
    // 19.9.1절 "생성자 함수에 의한 프로토타입의 교체" 참고
    constructor: Stack,

    // 스택의 가장 마지막에 데이터를 밀어 넣는다.
    push(value) {
      return this.array.push(value);
    },

    // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다.
    pop() {
      return this.array.pop();  
    },

    // 스택의 복사본 배열을 반환한다.
    entries() {
      return [... this.array];
    }
  }；
return Stack;
}())；

const stack = new Stack([1, 2]);
console.log(stack.entries()); // [l, 2]

stack.push(3);
console.log(stack.entries()); // [1, 2, 3]

stack.pop();
console.log(stack.entries()); // [l, 2]
```

- 스택을 클래스로 구현.

```jsx
class Stack {
  #array; // private class member
  constructor(array = []) {
    if (!Array.isArray(array)) {
      throw new TypeError('${array} is not an array.');
    }
    this.#array = array;
  }

  // 스택의 가장 마지막에 데이터를 밀어 넣는다.
  push(value) {
    return this.#array.push(value);
  }

  // 스택의 가장 마지막 데이터，즉 가장 나중에 밀어 넣은 최신 데이터# 꺼낸다.
  pop() {
    return this.#array.pop();
  }

// 스택의 복사본 배알융 반환한다.
  entries() {
    return [... this.#array];
  }
}

const stack = new Stack([l, 2]);
console.log(stack.entries()); // [1, 2]

stack.push(3);
console.log(stack.entries()); // [1, 2, 3]

stack.pop();
console.log(stack.entries()); // [1, 2]
```
<br>

### 27.8.5 Array.prototype.unshif

- unshift 메서드는 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티값을 반환.(직접 변경)

```jsx
const arr = [1, 2];

// 안수로 전달받은 모든 값율 완본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환.
let result = arr.unshift(3, 4);
console.log(result); // 4

// unshift 에서드는 원본 배열율 직접 변경.
console.log(arr); // [3, 4, 1, 2]
```

- unshift 메서드는 원본 배열을 직접 변경하는 부수 효과 존재에 따라 unshift 메서드보다는 ES6의 스프레드 문법 사용이 유용.

```jsx
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [3, ... arr];
console.log(newArr); // [3, 1, 2]
```
<br>

### 27.8.6 Array.prototype.shif

- shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환.(직접 변경)

```jsx
const arr = [1, 2];

// 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다.
let result = arr.shift();
console.log(result); // 1

// shift 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [2]
```

- shift 메서드와 push 메서드 사용을 통해 큐 구현 가능.

  - 큐는 데이터를 마지막에 밀어 넣고, 가장 먼저 밀어 넣은 데이터를 먼저 꺼내는 선입 선출(FIFO - First In First Out) 방식의 자료구조.
 
  - 스택은 언제나 마지막에 밀어 넣은 최신 데이터를 취득 하지만 큐는 언제나 데이터를 밀어 넣은 순서대로 취득.

  <div align="center">
    <img src="https://github.com/user-attachments/assets/1a059596-e471-4b25-b414-6c95da96cf26">
  </div>

- 큐를 생성자 함수로 구현.

```jsx
const Queue = (function () {
  function Queue(array = []) {
    if (!Array.isArray(array)) {
      // 47장 "에러 처리" 참고
      throw new TypeError( ${array} is not an array.');
    }
    this.array = array;
  }

  Queue.prototype = {
    // 19.9.1절 "생성자 함수에 의한 프로토타입의 교체" 참고
    constructor: Queue,

    // 큐의 가장 마지막에 데이터를 밀어 넣는다.
    enqueue(value) {
      return this.array.push(value);
    },
    // 큐의 가장 처음 데이터，즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
    dequeue() {
      return this.array.shift();
    }，
    // 큐의 복사본 배열을 반환한다.
    entries() {
      return [... this.array];
    }
  }；
return Queue;
}())；

const queue = new Queue([1, 2]);
console.log(queue.entries()); // [l, 2]

queue.enqueue(3);
console.log(queue.entries()); // [l, 2, 3]

queue.dequeue();
console.log(queue.entries()); // [2, 3]
```

- 큐를 클래스로 구현.

```jsx
class Queue {
  #array; // private class member

  constructor(array = []) {
    if (JArray.isArray(array)) {
      throw new TypeError( ${array} is not an array.');
    }
    this.#array = array;
  }

  // 큐의 가장 마지막에 데이터를 밀어 넣는다.
  enqueue(value) {
    return this.#array.push(value);
  }

  // 큐의 가장 차음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
  dequeue() {
    return this.#array.shift();
  }

  // 큐의 복사본 배열을 반환한다.
  entries() {
    return [ ... this.#array];
  }
}

const queue = new Queue([1, 2]);
console.log(queue.entries()); // [1, 2]

queue.enqueue(3);
console.log(queue.entriesO); // [1, 2, 3]

queue.dequeue();
console.log(queue.entries()); // [2, 3]
```
<br>

### 27.8.7 Array.prototype.concat

- concat 메서드는 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환하며, 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가.(원본 배열 변경 X)

```jsx
const arrl = [1, 2];
const arr2 = [3, 4];

// 배열 arr2를 원본 배열 arrl의 마지막 요소로 추가한 새로운 배열을 반환.
// 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가.
let result = arrl.concat(arr2);
console.log(result); // [l, 2, 3, 4]

// 숫자를 원본 배열 arrl의 마지막 요소로 추가한 새로운 배열을 반환.
result = arrl.concat(3);
console.log(result); // [1, 2, 3]

// 배열 arr2와 숫자를 원본 배열 arrl의 마지막 요쇼로 추가한 새로운 배열을 반환.
result = arrl.concat(arr2, 5);
console.log(result); // [1, 2, 3, 4, 5]

// 원본 배열은 변경 X.
console.log(arrl); // [l, 2]
```

- push와 unshift 메서드는 concat 메서드와 유사하게 동작하지만 차이 존재.(push & unshift -> concat 대체 가능)

  - push와 unshift 메서드는 원본 배열을 직접 변경으로 원본 배열을 반드시 변수에 저장 필요, concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환으로 반환값을 반드시 변수에 할당 필요.

  ```jsx
  const arrl = [3, 4];
  
  // unshift 메서드는 원본 배열을 직접 변경.
  // 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
  arrl.unshift(l, 2);
  // unshift 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
  console.log(arrl); // [1, 2, 3, 4j
  
  // push 메서드는 원본 배열을 직접 변경.
  // 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
  arrl.push(5, 6);
  // push 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
  console.log(arrl); // [l, 2, 3, 4, 5, 6]
  
  // unshift와 push 메서드는 concat 메서드로 대체 가능.
  const arr2 = [3, 4];
  
  // concat 메서드는 원본 배열을 변경하지 않끄 새로운 배열을 반환한다.
  // arrl.unshift(lt 2)를 다음과 같이 대체할 수 있다.
  let result = [1, 2].concat(arr2);
  console.log(result); // [1, 2, 3, 4]
  
  // arrl.push(5f 6)를 다음과 같이 대체할 수 있다.
  result = result.concat(5, 6);
  console.log(result); // [l, 2, 3, 4, 5, 6]
  ```

  - 인수로 전달받은 값이 배열인 경우 push와 unshift 메서드는 배열을 그대로 원본 배열의 마지막/첫 번째 요소로 추가하지만 concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가.

  ```jsx
  const arr = [3, 4];
  
  // unshift와 push 메서드는 안수로 전달받은 배열을 그대로 원본 배열의 요소로 추가.
  arr.unshift([1, 2]);
  arr.push([5, 6]);
  console.log(arr); // [[1, 2], 3, 4,[5, 6]]
  
  // concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 요소로 추가.
  let result = [1, 2].concat([3, 4]);
  result = result.concat([5, 6]);
  console.log(result); // [1, 2, 3, 4, 5, 6]
  ```

- concat 메서드는 ES6의 스프레드 문법으로 대체 가능.

```jsx
let result = [1, 2].concat([3, 4]);
console.log(result); // [l, 2, 3, 4]

// concat 메서드는 ES6의 스프레드 문법으로 대체할 수 있다.
result = [ ... [1, 2], ... [3, 4]];
console.log(result); // [1, 2, 3, 4]
```

- push/unshift 메서드와 concat 메서드를 사용하는 대신 ES6의 스프레드 문법을 일관성 있게 사용하는 것을 권장.
