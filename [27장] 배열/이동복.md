## 27.1 배열이란?

여러 값을 순자적으로 나열한 자료구조

`요소`, `인덱스`, `length`, `프로퍼티 배열은 객체 타입`

배열 생성 방법
1. 배열 리터럴
2. Array 생성자 함수 -> Array
3. Array.of / Array.from

- 배열 프로토타입 객체는 Array.prototype이고 빌트인 메서드 제공한다

```jsx
const arr = [1, 2, 3];
arr.constructor === Array // -> true
Object getPrototypeOf(arr) === Array.prototype // -> true
```

## 27.2 자바스크립트 배열은 배열이 아니다
자료구조에서 배열이란 동일한 크기의 메모리 공간이 연속적으로 나열된 것을 말한다.

배열의 요소는 하나의 데이터 타입으로 통일되었으며 서로 연속적으로 인접해 있는데 이를 밀집 배열이라 한다.
선형 검색 -> 시간 복잡도 O(n)

```jsx
// 선형 검색으로 배열에 특정 요소가 존재하는지 확인 
// 배열에 특정 요소가 존재하면 해당 요소의 인덱스 반환, 아니면 -1 반환
function linearSearch(arr, target) {
	const length = arr.length;

	for(let i = 0; i < length; i++) {
		i (arr[i] === target) return i;
	}
	return -1;
}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2 
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
```

인덱스 중간에 요소를 삽입, 또는 삭제하는 경우 앞, 뒤로 인접한 요소들을 이동시켜야 한다. <br/>
**자바스크립트의 배열은 배열 동작은 흉내 낸 특수한 객체이다.**
- JS 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 갖는다.
- length 프로퍼티를 갖는다.
- 요소는 프로퍼티의 값이다.
- 프로퍼티이므로 모든 타입의 값이 요소 값이 될 수 있다.
- 배열은 해시 테이블로 구현된 객체로 인덱스로 요소에 접근하는 일반 배열보다 성능이 느린 구조적 단점을 갖는다.
- 요소를 삽입, 삭제하는 경우에 일반적인 배열보다 빠른 성능을 갖는다.
- 성능 면에서 일반 객체보다 약 2배 정도 빠르다.

```jsx
const arr= [];
console time ('Array Performance Test');

for (let i = 0; i < 100000000 i++) {
	arr[i];
}

// Array Performance Test 2609.456787109375ms
console.timeEnd ('Array Performance Test');

const obj = 1:
console.timeEnd(Object Performance Test):

for (let i = 0; i < 100000000; i++) {
	obj[i] = i;
}

// Obeject Performance Test 3049.701171875ms
console.timeEnd('Object Performance Test');
```

## 27.3 length 프로퍼티와 희소 배열

1. length 프로퍼티는 요소의 개수를 나타낸다.
2. length 프로퍼티의 값은 빈 배열의 경우 0, 아닌 경우 최대 index + 1이다.
3. 요소가 추가되거나 삭제될 때 length 자동 반영
4. 배열이 가진 요소보다 많이 length 값을 지정하면 빈 값은 물론 메모리 메모리 할당도 하지 않는다. (empty로 표현)
5. 배열의 요소가 일부 비어있는 배열을 희소 배열이라 한다.
6. 자바스크립트는 희소 배열을 문법적으로 허용한다.
7. 희소 배열은 length와 배열 요소의 개수가 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 항상 크다.
8. 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.

## 27.4 배열 생성

### 27.4.1 배열 리터럴

```jsx
const arr = [];
arr.length; // 0

// 요소를 생략하면 희소 배열이 된다.
const arr = [0, , ];

// 희소 배열의 length는 요소 갯수보다 항상 많다
console.log(arr.length);  // 2
console.log(arr); // [0, empty]
```

### 27.4.2 Array 생성자 함수

1. Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작한다.
2. 일반 함수처럼 호출하여도 Array 생성자 함수 내부에서 new.target을 확인하므로 상관없이 생성자 호출된다.

```jsx
// 길이가 10인 empty를 요소로 하는 배열 생성 
// 실제 요소 값은 존재하지 않는다.
const arr = new Array(10);
console. log(arr); // [empty × 10] 
arr.length; // 10
```

### 27.4.3 Array.of

- ES6에서 도입된 메서드로 전달된 인수를 요소로 갖는 배열을 생성한다.

``` jsx
Array.of(1, 2, 3);
```

## 27.4.4 Array.from

- 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

```jsx
Array.from({ length: 4, 0: 'a’, 1: ‘b' });

// 문자열은 이터러블이다.
Array from('Hello');
```

```jsx
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from( { length: 3 } ); // [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환 값으로 구성된 배열을 반환한다.
Array.from({ length: 3 } ), (_, i) => i * 2); //  [0, 2, 4]
```

**유사 배열 객체와 이터러블 객체**
- 유사 배열 객체(array-like object)는 배열처럼 인덱스로 프로퍼티 값에 접근, length 프로퍼티를 갖는 객체
- for 문으로 순회 가능하다.

```jsx
const arrLike = {
	length: 3,
	0: ‘a’,
	1: ‘b’,
	2: ‘c’
};

console.log(arrLike.length); // 3
console.log(arrLike[2]) // c

for(let i = 0; i < arrLike.length; i++) {
	console.log(arrLike(i)); // a, b, c
}
```

- 이터러블 객체(terable object)은 Symbol.iterator 메서드를 구현하여 for ... of 문으로 순회 가능하다.
- 스프레트 문법, 배열 디스트럭처링 할당의 대상으로 사용 가능한 객체이다.
- ES6에서 제공하는 빌트인 이터러블은 Array. string, Map, Set DOM 컬렉션 (NodeList, HTMLCollection) arguments 등이 있다.

## 27.5 배열 요소의 참조

1. 대괄호 표기법으로 배열 요소를 참조한다.
2. 존재하지 않는 요소에 접근하면 undefined를 반환한다. (희소 배열도 마찬가지)

```
// 희소 배열
const arr = [1, , 3];

// 배여 arr에는 인덱스가 1인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));

/*
	'0': {value: 1, writable: true, enumerable: true, configurable: true}
	'2': {value: 3, writable: true, enumerable: true, configurable: true}
	length: {value: 3, writable: true, enumerable: false, configurable: false}
*/
```

## 27.6 배열 요소의 추가와 갱신

1. 배열의 요소 또한 객체와 같이 동적으로 추가 가능하다.
2.. 인덱스에 정수가 아닌 값을 넣으면 요소가 아닌 프로퍼티가 추가된다.

```jsx
const arr = [0];
arr[1] = 1;
arr[1.11] = 1.1:

// 정수로 표현되는 문자열도 배열의 요소로 추가된다.
arr['2'] = 2;
arr.length; // 3
```

## 27.7 배열 요소의 삭제
-   배열은 객체이므로 delete 연산자로 특정 요소 삭제가 가능하다. length 프로퍼티 반영 x 희소 배열 생성 0
-   Array prototype.splice 메서드로 특정 요소 삭제하는 것이 낫다. length 프로퍼티 반영 o, 희소 배열 생성 X

```jsx
const arr = [0, 1, 2];

arr.splice(1, 1);

console log(arr.length): // 2
console log(arr): // (2) [0, 2]
```

## 27.8 배열 메서드

배열에는 `원본 배열을 직접 변경하는 메서드`와 원본 배열을 직접 변경하지 않고 `새로 배열을 생성하여 반환하는 메서드`가 있다.

```jsx
const arr = [0, 1, 2];

// push 메서드는 원본 배열을 반환한다.
arr.push(3);

// concat 메서드는 원본 배열이 아닌 새로운 배열을 생성하여 반환한다.
const result = arr.concat(4);
```

## 27.8.1 Array.isArray

- Array 생성자 함수의 정적 메서드이다.
- 전달된 인수가 배열이면 true, 아니면 false를 반환한다.
- `Array.of` 와 `Array.from` 또한 Array 생성자 함수의 정적 메서드이다.

## 27.8.2 Array.prototype.indexof

1. 인수로 전달된 요소를 검색해서 인덱스를 반환 
2. 검색된 요소가 중복된다면 첫 번째로 검색된 요소를 반환 
3. 검색된 요소가 없다면 -1을 반환

``` jsx
const arr = [1, 2, 2, 3];
console.log(arr.indexOf(1)); // 0
console.log(arr.indexOf(4)): // -1

// 두번째 인수는 검색을 시작할 인덱스
console.log(arr.indexOf(2, 2)); // 2
``` 

``` jsx
// ES7에 도입된 Array.prototype indudes 서드는 가독성이 더 좋다.
const arr = ['사과', '딸기', '오렌지'];

if(!arr.includes('바나나'){
	arr.push('바나나');
}

console.log(arr); // ['사과', '딸기', '바나나', '오렌지']
``` 

## 27.8.3 Array.prototype.push

- ﻿﻿인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환

``` jsx
const arr = [0];

// 변경된 length 프로퍼티 값을 반환
console.log(arr.push(1, 2)); // 3

// 원본 배열을 직접 변경한다.
console.log(arr) // [0, 1, 2]

// arr.push(3)과 동일하며 push 메서드보다 빠르다
arr[arr.length] = 3;
console log(arr): 1/ (4) [0, 1, 2, 3)
}
```

push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다.
push 메서드보다 ES6의 스프레드 문법을 지향 (부수효과도 없음)

```jsx
const arr = [0, 1];
const newArr = [..arr, 2];

newArr // (3) [0, 1, 2]
```

## 27.8.4 Array.prototype.pop

- ﻿﻿원본 배열에서 마지막 요소 제거 후 마지막 요소 반환
- ﻿﻿원본 배열이 빈 배열이면 undefined을 반환하고 원본 배열을 직접 변경

```jsx
const arr = [0, 1];
let lastEl = arr.pop();
lastEl  // 0
```

- pop, push 메서드를 사용하여 스택을 구현할 수 있다.
- 스택은 후입 선출 구조로(Last In First Out), 스택에 데이터를 넣는 것을 푸쉬, 스택에서 데이터를 꺼내는 것을 팝이라고 한다.

```jsx
// 생성자 함수로 스택 구현하기
const Stack = (function(){
	function Stack(array = 0) {
		if(!Array isArray(array)) {
			throw new TypeError(`${array} is not an array.`);
		this.array = array
		}
	}

	Stack.prototype = {
		constructor: Stack,	
		push(value) { return this. array.push(value) },
		pop () {	return this.array.pop(); },
		entries() {	return [...this.array); }
	}
	
	return Stack;
}());

const stack = new Stack([1, 2]):
console.log(stack.entries()); // [1, 2]

stack push(3);
console.log(stack.entries); // [1, 2, 3]

stack.pop();
stack.pop();
stack.pop();

console.log(stack.entries()); // []
```

```jsx
// 클래스로 스택 구현하기
class Stack {
	constructor(arr = 0) {
		if(!Array.isArray(arr)) {
			throw new TypeError(`${arr}은 배열이 아니애옹`);
		}
		this.#arr = arr;
	}
	
	push(value) { return this.#arr.push(value); }
	pop() { return this.#arr.pop(); }
	entries() { return [this.#arr] }
}

const stack = new Stack([0, 1]):

stack.pop();
console.log(stack.entries()): // [0]
stack.push(2); 
stack.push(1):

console.log(stack.entries()); // (3) [0, 2, 1]
```

## 27.8.5 Array prototype.unshift

- ﻿﻿인수로 전달받은 모든 값은 원본 배열의 선두에 요소로 추가
- ﻿﻿변경된 length 프로퍼티 반환
- ﻿﻿원본 배열을 직접 변경

```jsx
const arr = [1];

// length 반환
let result = arr.unshift(-1, 0);

// 원본 배열 직접 변경
console.log(result) // 3

arr // (3) [-1, 0, 1]

const newArr = [-2, ...arr]; // [-2, -1, 0, 1]
```

## 27.8.6 Array.prototype.shift

- 첫 번째 요소 제거하고 제거한 요소 반환 
- 빈 배열이면 undetined 반환
- 원본 배열을 직접 변경

```jsx
const arr = [1];

console log(arr.shift()); //1 
console.log(arr.shift()); // undefined

arr; // []
```

- shift 메서드와 push 메서드로 큐 구현하기
- 큐는 선입 선출 구조(FIFO - First In First Out)

```jsx
// 생성자 함수로 큐 구현하기
const Queue = (function() {
	// 초기화
	function Queue = (arr) {
		this.arr = anr
	}

	// 메서드
	Queue prototype = {
		push(value) {  return this.arr.push (value); },
		shift() { return this.arr.shift(); },
		entries() { return [..this.arr]; }
	}
	// 반환
	retum Queue;
}());

const q = new Queue([1, 2, 3]);
q.push (4);
q.push (5);

console.log(q.entries()); // [1, 2, 3, 4, 5]

q.shift();
q.shift();
q.shift();

console.log(q.entries()); // [1, 2] 

q.shift();
q.shift();

consolelog(q.entries()); // []
```

```jsx
// 클래스로 큐 구현하기
class Queue {
	constructor(arr) {
		this.arr = arr
	}
	
	push(value) { return this.arr.push(value); }
	shift() { return this.arr.shift(); } 
	entries() { return [...this.arr]; }
}
```

## 27.8.7 Array.prototype.concat

- ﻿﻿인수로 전달된 값들(배열, 원시값)을 원본 배열의 마지막 요소로 추가하여 신규 배열 반환
- ﻿﻿인수로 전달한 값이 배열인 경우 배열을 요소로 해체하여 추가
- ﻿﻿원본 배열은 변경되지 않음

```jsx
const arr = [1, 2];
const arr2 = [3, 4]:

let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4]

result = arr1.concat(3);
console.log(result): I/ [1, 2, 3]

result = arr1.concat(arr2, 5);
console.log(result); // [1, 2, 3, 4, 5] 

console.log(arr1); // [1, 2]
```

- ﻿﻿push와 unshit 메서드는 원본 배열을 직접 변경한다.
- ﻿﻿concat 메서드는 신규 배열을 반환한다.

```jsx
const arr1 = [3, 4];

// 배열 직접 변경
arrt.unshift(1, 2);

console.log(arr1); [1, 2, 3, 4]

// 배열 직접 변경
arr.push(5, 6);
console.log(arrt), // [1, 2, 3, 4, 5, 6]

const arr2 = [3, 4];

// 원본 배열 변경 x
let result = [1, 2].concat(arr2):
console.log(result); // [1, 2, 3, 4]

// 원본 배열 변경 x
result = result.concat(5, 6);
console.log(result), // [1, 2, 3, 4, 5, 6]
```

- ﻿﻿인수로 전달받은 값이 배열이면 push와 unshift 메서드는 원본 배열의 마지막, 첫 번째 요소로 추가
- ﻿﻿concat 메서드의 경우 인수인 배열을 해체하여 새로운 배열의 마지막 요소로 추가

```jsx
const arr = [3, 4];
arr.unshift([1, 2]);
arr. push([5, 6]);

console.log(arr): // [[1, 2], 1, 3, 4, [5, 6]]

let result = [1, 2].concat(3, 4):
result = result.concat([5, 6]):

console.log(result); // [1, 2, 3, 4, 5. 6]
```

- concat 메서드는 스프레드 문법으로 대체 가능

```jsx
let result = [1, 2].concat(3, 4):
console.log(result); // [1, 2, 3, 4]

result = [..[1, 2], ...[3, 4]):
console.log(result); // [1, 2, 3, 4]
```

- push/unshift 메서드와 concat 메서드 보다 스프레드 문법을 일관성 있게 사용하도록 하자
